\input{../header.tex}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Programmation orientée objet: Héritage et Polymorphisme - Exercices basiques}

Le but de cette séance est d'approfondir les notions de programmation orientée objet vues précédemment. Nous commencerons par un rappel des notions de surcharge d'opérateurs avant d'introduire des exercices sur l'héritage et le polymorphisme. Au terme de cette séance, vous devez être en mesure de factoriser votre code afin de le rendre mieux structuré et plus lisible. À chaque exercice, le langage de programmation à utiliser sera spécifié.

Le code présenté dans les énoncés se trouve sur Moodle, dans le dossier \lstinline{Code}.

\section{Rappel: Surcharge des opérateurs - Python}
Dans cette section, vous manipulerez des fractions sous forme d'objets. Vous ferez des opérations de base sur ce nouveau type d'objets.\\

\begin{note}{"Nathan"}
    q1-6: basique
    q7: avancé
    q8: avancé
    q9-11: basique
    q12,13: avancé
    q14,15: basique
    q16,17: avancé
\end{note}

\begin{Exercice}[5 minutes] \textbf{Création de classe} \\
    Dans un projet que vous aurez au préalable préparé, créez un fichier nommé \lstinline{surcharge.py}.
    À l'intérieur de ce fichier, créez une classe \lstinline{Fraction} qui aura comme attributs privés un numérateur et un dénominateur. 
\end{Exercice}

\begin{Exercice}[5 minutes] \textbf{Constructeur par défaut} \\
Définir un constructeur à votre classe. Assignez des valeurs par défaut à vos attributs. \\
Si un seul argument est passé à votre constructeur, la fraction devra être égale à l'entier correspondant.\\
Empêchez l'utilisateur d'assigner la valeur \lstinline{zéro} au dénominateur.

    \begin{conseil}
		Les valeurs par défaut seront assignées à votre objet au cas où il est instancié sans valeurs. Ainsi en faisant \lstinline{f = Fraction()}, on obtiendra un objet \lstinline{Fraction} ayant pour valeurs un numérateur à 0 et un dénominateur à 1 soit $\frac{0}{1}$.\\
		En Python, vous pouvez donner des valeurs par défaut aux arguments de vos méthodes lors de leur définition. Par exemple, vous pouvez faire: 
			\lstinline{def add(self, x=10, y=5):...}
    \end{conseil}
\end{Exercice}

\begin{Exercice}[5 minutes] \textbf{Type casting}\\
	Convertir les attributs en entier.
	\begin{conseil}
		Pensez à utiliser la fonction \lstinline{int}.
	\end{conseil}
\end{Exercice}

\begin{Exercice}[5 minutes] \textbf{Redéfinition de méthodes} \\
	Redéfinir la méthode \lstinline{__str__()} pour produire une représentation textuelle de vos objets \lstinline{Fraction}.
	\begin{conseil}
		Une fois la méthode \lstinline{__str()__} redéfinie, lorsqu'on fera un \lstinline{print()} sur une instance de votre classe \lstinline{Fraction}, il affichera le message suivant: \textit{Votre fraction a pour valeur \lstinline{numérateur/dénominateur}}. \lstinline{Numérateur} et \lstinline{dénominateur} étant les valeurs que vous passerez à votre objet \lstinline{Fraction}.
	\end{conseil}
\end{Exercice}

\begin{Exercice} [5 minutes] \textbf{Accesseurs et mutateurs} \\
	Créer des \lstinline{getters} et \lstinline{setters} pour chacun des attributs de votre classe \lstinline{Fraction}.
\end{Exercice}

\begin{Exercice} [10 minutes] \textbf{Simplification de fractions}\\
	Définir une méthode \lstinline{simplification} qui réduit la \lstinline{Fraction}. Cette méthode ne renverra rien, elle modifiera simplement l'instance. Pour la suite des exercices, assurez-vous de toujours manipuler des fractions simplifiées. Pour ce faire, vous pouvez faire appel à votre méthode \lstinline{simplification} après chaque opération sur un objet de type \lstinline{Fraction}.

	\begin{conseil}
		Afin de simplifier une fraction, vous devez diviser le numérateur et le dénominateur par leur plus grand diviseur commun. Pensez à utiliser la méthode \lstinline{math.gcd} pour trouver le plus grand diviseur commun entre deux nombres.
	\end{conseil}
\end{Exercice}

\begin{Exercice}[15 minutes] \textbf{Redéfinition de méthodes - \_\_eq\_\_}\\
	Redéfinir la méthode d'instance \lstinline{__eq__} qui prend en entrée un objet \lstinline{Fraction} que vous nommerez \textit{other} (en plus de \lstinline{self}) et qui renvoie \lstinline{True} si \lstinline{self} et l'objet passé en argument ont la même valeur.
	\begin{conseil}
		Pour vérifier l'égalité entre $a/b$ et $c/d$, tester que $a*d$ est égal à $b*c$. \\
		Utilisez la méthode \lstinline{isinstance()} afin de vérifier que \textit{other} est bien de type \lstinline{Fraction}. Dans le cas contraire, affichez un message d'erreur.
		\\La fonction \lstinline{isinstance} prend en entrée une valeur et un type. Elle vérifie que cette valeur est du type défini. Par exemple: \lstinline{isinstance(nombre, int)} renverra \lstinline{True} si la variable \lstinline{nombre} est de type \lstinline{int} et \lstinline{False} dans le cas contraire.
	\end{conseil}
\end{Exercice}

\begin{Exercice}[15 minutes] \textbf{Addition et multiplication}\\
	Redéfinir les méthodes \lstinline{__add__} et \lstinline{__mul__} afin d'effectuer des opérations d'addition et de multiplication sur vos objets de type \lstinline{Fraction}. Attention, ces méthodes devront renvoyer des objets de type \lstinline{Fraction}. Dans vos méthodes \lstinline{__add__} et \lstinline{__mul__}, n'oubliez pas de simplifier ces fractions avant de les retourner.\\
	Gérer le cas où l'élément passé en argument n'est ni une \lstinline{Fraction}, ni un \lstinline{int}.
\end{Exercice}


\begin{solution}
	\lstinputlisting{solutions/surcharge1.py}
\end{solution}
\begin{solution}
	\lstinputlisting{solutions/surcharge2.py}
\end{solution}

\newpage

\section{Notions d'héritage - Java}

Le but de cette partie est de mettre en pratique les notions liées à l'héritage. 
Nous allons créer une classe \lstinline{Livre()} qui représentera notre classe-mère. Nous allons également créer deux classes filles, \lstinline{Livre_Audio()} et \lstinline{Livre_Illustre()}. Les classes filles hériteront des attributs et méthodes de la classe-mère. \\

\begin{Exercice}[20 minutes] \lstinline{Création des différentes classes}\\
Créez la classe-mère \lstinline{Livre} avec les caractéristiques suivantes:
\begin{itemize}
	\item un attribut \lstinline{privé String} nommé \lstinline{titre},
	\item un attribut \lstinline{privé String} nommé \lstinline{auteur},
	\item un attribut \lstinline{privé int} nommé \lstinline{annee},
	\item un attribut \lstinline{privé int} nommé \lstinline{note} (initialisé à \lstinline{-1}),
	\item le \lstinline{constructeur} de la classe qui prendra les trois premiers arguments cités ci-dessus,
	\item une méthode \lstinline{setNote()} qui permet de définir l'attribut \lstinline{note},
	\item une méthode \lstinline{getNote()} qui permet de retourner l'attribut \lstinline{note},
	\item une méthode \lstinline{toString()} qui retournera le titre, l'auteur, l'année et la note d'un ouvrage \lstinline{note} (réécrire cette méthode permettra d'afficher un objet \lstinline{Livre} en utilisant \lstinline{System.out.println()}). \\
\end{itemize}

Attention, si la \lstinline{note} n'a pas été modifiée et qu'elle vaut toujours \lstinline{-1}, affichez ``Note : pas encore attribuée'' au lieu de ``Note : \lstinline{note}'' via la méthode \lstinline{toString()}. \\


Créez les classes filles avec les caractéristiques suivantes:\\
\lstinline{class Livre_Audio extends Livre}
\begin{itemize}
	\item un attribut \lstinline{privé String} nommé \lstinline{narrateur}

\end{itemize}
\lstinline{class Livre_Illustre extends Livre}
\begin{itemize}
	\item un attribut \lstinline{privé String} nommé \lstinline{illustrateur}

\end{itemize}

Voici le squelette du programme à compléter:

\begin{lstlisting}
	class Livre {

	}

	class Livre_Audio extends Livre {

	}

	class Livre_Illustre extends Livre {

	}\end{lstlisting}

\begin{conseil}
En Java, lors de la déclaration d'une classe, le mot clé \lstinline{extends} permet d'indiquer qu'il s'agit d'une classe fille de la classe indiquée. 

Le mot clé \lstinline{super} permet à la sous classe d'hériter d'éléments de la classe-mère. \lstinline{super} peut être utilisé dans le constructeur de la classe-fill selon l'example suivant: \lstinline{super(attribut_mère_1, attribut_mère_2, attribut_mère_3, etc.);}. Ainsi, il n'est pas nécessaire de redéfinir tous les attributs d'une classe fille !

L'instruction \lstinline{super} doit toujours être la première instruction dans le constructeur d'une classe-fille.

Vous pouvez vous servir de \lstinline{'\\n'} dans une chaîne de caractères pour effectuer un retour à la ligne lors de l'affichage d'une chaîne de caractères.
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/heritage-solution-1.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[5 minutes] \lstinline{Méthode et héritage} \\

Maintenant que vous avez créé la classe-mère et les classes filles correspondantes, vous pouvez créer un objet \lstinline{Livre} à l'aide du constructeur de la classe \lstinline{Livre_Audio} (et des arguments donnés lors de la création de l'objet).

% TODO: Phrase à reformuler. S'agit-il de valeurs par défaut du constructeur ou des valeurs de l'instance?

En instanciant l'objet, vous pourriez utiliser les valeurs suivantes :\\
titre: ``Hamlet'', auteur: ``Shakespeare'', année: ``1609'' et le narrateur ``William''.\\

Une fois l'objet créé, attribuez-lui une note à l'aide de la méthode \lstinline{setNote()} définie précédemment.\\ 

Finalement, utilisez la méthode \lstinline{System.out.println()} pour afficher les informations du livre.\\

Redéfinir la méthode \lstinline{toString()} de la classe \lstinline{Livre_Audio} afin que la valeur de l'attribut \lstinline{narrateur} soit affichée.

Faites pareil avec la classe \lstinline{Livre_Illustre} et son attribut \lstinline{Illustrateur}

\begin{conseil}
\textbf{Attention}, vous devez créer un objet \lstinline{Livre} et non \lstinline{Livre_Audio}.

Le mot-clé \lstinline{super} peut être utilisé dans la redéfinition d'une méthode selon l'exemple suivant: \lstinline{super.nom_de_la_methode();}. Le mot clé \lstinline{super} représente la classe parent, tout comme le mot clé \lstinline{this} fait référence à l'instance avec laquelle la méthode est appelée. 


L'instruction \lstinline{super} doit toujours être la première instruction dans le redéfinition d'une méthode dans une classe fille. 
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/heritage-solution-2.java}
	\lstinputlisting{Solutions/heritage-solution-3.java}
\end{solution}

\end{Exercice}

\newpage
Lorsque toutes les étapes auront été effectuées, placez le code suivant dans votre \lstinline{main} et exécutez votre programme:\\

\lstinputlisting{ressources/heritage-main.java}


Vous devriez obtenir : \\


\lstinputlisting{ressources/heritage-main-prompt.java}

\newpage
\section{Polymorphisme - Java}

Les exercices de cette section sont la suite des exercices de la section 2 de la semaine passée.
N'hésitez pas à réutiliser les solutions disponibles sur Moodle.


Dans cette partie, vous devez créer 2 nouvelles classe-filles de la classe-mère \lstinline{Fighter}. La première classe représentera un \lstinline{Soigneur}, qui, lorsqu'il ``attaquera'' un \lstinline{Fighter}, le soignera au lieu de le blesser. La deuxième classe représentera un Fighter spécialisé dans l'attaque \lstinline{Attaquant}, qui aura la capacité d'attaquer un certain nombre de fois (ce nombre sera défini lors de l'instanciation).\\

% Voici le squelette du code que vous trouverez également dans le dossier code sur Moodle : \\
Avant d'effectuer la série de questions suivantes, téléchargez le fichier \lstinline{fighter-squelette.java} disponible sur Moodle.\\

% \lstinputlisting{ressources/fighter-squelette.java}

\begin{Exercice}[5 minutes] classe-fille \lstinline{Soigneur} \\
Commencez par déclarer une nouvelle classe-fille \lstinline{Soigneur}. Cette classe-fille aura un nouvel attribut privé nommé \lstinline{résurrection} qui vaudra 1 lors de l'instanciation de la classe. \\

Créez le constructeur de cette classe ainsi que les \lstinline{getter} et \lstinline{setter} permettant d'interagir avec le nouvel attribut (\lstinline{résurrection}). \\

\begin{conseil}
Pensez à utiliser le constructeur de votre classe-mère \lstinline{Fighter}
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/soigneur.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[15 minutes] Méthode \lstinline{résurrection(Fighter other)} de la classe-fille \lstinline{Soigneur} \\
Créez une méthode \lstinline{résurrection(Fighter other)} qui permettra de faire revenir un \lstinline{Fighter} à la vie, mais le \lstinline{Soigneur} ne pourra le faire qu'une seule fois. \\

Commencez par contrôler que l'instance depuis laquelle la méthode est appelée soit toujours en vie. Si ce n'est pas le cas, indiquez : \lstinline{nom_instance} est mort et ne peut plus rien faire.  \\ 

Contrôlez ensuite que l'instance \lstinline{other} soit vraiment morte. Si ce n'est pas le cas, indiquez le en affichant le texte suivant : ``\lstinline{nom_other} est toujours en vie.'' \\

Pour finir, contrôlez que l'attribut \lstinline{résurrection} de l'instance depuis laquelle la méthode est appelée est égale à 1. Si ce n'est pas le cas, indiquez : \lstinline{nom_instance} ne peut plus ressusciter personne.\\

Si tous ces éléments sont réunis, faites revenir le \lstinline{Fighter} \lstinline{other} à la vie en lui remettant 10 points de vie et en l'ajoutant à la liste \lstinline{instances} de la classe \lstinline{Fighter}. Pensez aussi à:

\begin{itemize}
	\item Mettre l'attribut \lstinline{résurrection} de l'instance appelée à 0 afin de l'empêcher de réutiliser ce pouvoir,
	\item appeler la méthode \lstinline{checkHealth()}, et à indiquer : ``\lstinline{nom_other} est revenu à la vie !''
\end{itemize}

\begin{conseil}
Utilisez un branchement conditionnel pour les contrôles. \\

Une nouvelle méthode nommée \lstinline{addInstances(Fighter other)} a été créée dans la classe \lstinline{Fighter}. Regardez à quoi elle sert et utilisez la. \\

Pour les indications en fonction des différentes conditions, imprimez simplement la phrase en question. \\
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/resurrection.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[10 minutes] Méthode \lstinline{attack} de la classe-fille \lstinline{Soigneur} \\

Réécrivez la méthode \lstinline{attack} de la classe-fille \lstinline{Soigneur} afin d'ajouter des points de vie à \lstinline{other} au lieu de lui en retirer. \\

Le seul argument nécessaire pour cette méthode sera une autre instance de \lstinline{Fighter} qu'on pourrait nommer \lstinline{other}. \\

Commencez par contrôler que le \lstinline{Soigneur} depuis lequel la méthode est appelée est encore en vie. Si ce n'est pas le cas, affichez : ``\lstinline{nom_instance} est mort et ne peut plus rien faire.''

Contrôlez ensuite que le \lstinline{Fighter} \lstinline{other} est toujours en vie. Si ce n'est pas le cas indiquez : ``\lstinline{nom_other} est déjà mort, ressuscitez-le afin de pouvoir le soigner.'' Contrôlez également qu'il ait moins de 10 points de vie. Si ce n'est pas le cas, indiquez le via le texte suivant: ``\lstinline{nom_other} a déjà le maximum de points de vie.'' \\

Si toutes ces conditions sont réunies, ajoutez la valeur de l'attaque de l'instance qui appelle la méthode aux points de vie de \lstinline{other}, puis appelez la méthode de classe \lstinline{checkHealth()}.

\begin{conseil}
Pensez à utiliser un branchement conditionnel pour les contrôles. \\

Le nombre de points de vie à ajouter est simplement égal à l'attaque de l'instance depuis laquelle la méthode est appelée. Ajoutez la valeur de cet attribut \lstinline{attack} au \lstinline{Fighter} \lstinline{other}.

\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/soigneur-attack.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[5 minutes] Classe-fille \lstinline{Attaquant} \\

Commencez par déclarer une nouvelle classe-fille \lstinline{Attaquant} héritant de la classe \lstinline{Fighter}. Cette classe-fille prendra un nouvel attribut privé nommé \lstinline{multiplicateur} de type \lstinline{int}, qui sera passé comme argument du \lstinline{constructeur} de la classe-fille. \\

Déclarez le \lstinline{constructeur} de cette classe ainsi que les \lstinline{getter} et \lstinline{setter} permettant d'interagir avec ce nouvel attribut \lstinline{multiplicateur}. \\

\begin{conseil}
Pensez à utiliser le \lstinline{constructeur} de votre classe-mère \lstinline{Fighter}.
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/attaquant.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[10 minutes] Méthode \lstinline{attack} de la classe-fille \lstinline{Attaquant} \\

Réécrivez la méthode \lstinline{attack} de la classe-fille \lstinline{Attaquant} afin d'effectuer plusieurs attaques sur \lstinline{other} en fonction de l'attribut \lstinline{multiplicateur}. \\

Assurez-vous de toujours indiquer le type de l'attaque lorsque vous faites appel à la méthode \lstinline{attack()}.

\begin{conseil}
Pensez à contrôler que l'instance depuis laquelle la méthode est appelée est encore en vie.
Aidez-vous de la méthode \lstinline{attack} de la classe-mère \lstinline{Fighter}.\\

Pour effectuer plusieurs attaques, vous pouvez utiliser une boucle allant de 0 à \lstinline{multiplicateur}.

\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/attaquant-attack.java}
\end{solution}

\end{Exercice}

Si tout est correct, en utilisant ce \lstinline{main} : \\

\lstinputlisting{ressources/combattant-main.java} 

Vous devriez obtenir : \\

\lstinputlisting{Solutions/combattant-main-solution.java} 

\end{document}
