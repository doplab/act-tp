\input{../header.tex}
\usepackage{array}
\usepackage{blindtext}
\usepackage{multicol}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\ShowNotetrue
\titre
\cours{Consolidation 2}

Les exercices de cette série sont une compilation d'exercices semblables à ceux vus lors des semaines précédentes. Le but de cette séance est de consolider les connaissances acquises lors des travaux pratiques des dernière semaines.\\

% Exercice complexité - Maeva
\begin{Exercice}[10 minutes] \textbf{Complexité} \\
	Analysez la complexité des deux programmes ci-dessous. Ont-ils la même complexité? 
    	\lstinputlisting{resources/ex1_enonce.py}

	% Solutions complexité - Maeva
	\begin{solution}
	Non, ils n'ont pas la même complexité. \lstinline{fun()} a une complexité de $O(n*n)$ car il s'agit de deux boucles imbriquées itérant chacune n fois dans le pire des cas. En revanche, \lstinline{fun2()} a une complexité de $O(n+n)$ car elle contient deux boucles effectuant des opérations indépendantes. 
	\end{solution}
\end{Exercice}

\begin{comment}
% Exercice complexité - Maeva
\begin{Exercice}[10 minutes]\textbf{Complexité}\\
	Quel est la complexité de ce code ?
   	 \lstinputlisting{resources/ex2_enonce.py}
	 % Exercice complexité - Maeva
	 \begin{solution}
		%TODO 
	\end{solution}
\end{Exercice}
\end{comment}

% Exercice nombres impaire - Maeva
\begin{Exercice}[10 minutes] \\
	Ecrivez un programme Python qui imprime tous les nombres impairs à partir de 1 jusqu’à un nombre \lstinline{n} défini par l’utilisateur. Ce nombre \lstinline{n} doit être supérieur à 1.
	Exemple : si n = 6, résultat attendu : 1, 3, 5
% Solutions nombres impaire - Maeva
	\begin{solution}
   		 \lstinputlisting{solutions/exercise3.py}
	\end{solution}
\end{Exercice}

% Exercice arbres binaires - Maeva
\begin{Exercice}
	Lesquels de ces arbres sont des arbres binaires (binary tree) ? Donnez leur hauteur (height).
	\begin{figure}[h!]
        		\centering
       	 	\includegraphics[width=18cm]{resources/exercice5.png}
    	\end{figure}
	% Solution arbres binaires - Maeva
	\begin{solution}
		Seuls les arbres 3, 4 et 5 sont des arbres binaires selon la définition donnée en cours. En effet, l'ordre d'insertion des éléments est incorrect dans les arbres 1 et 2. 
		Quant à leurs hauteurs, elles sont respectivement de 3, 3, 3, 1 et 4.
	\end{solution}
\end{Exercice}


% Exercice complexité - Etienne
\begin{Exercice}[10 minutes]\textbf{Croissance de fonctions}\\
	Trier la liste de fonctions suivante selon leur croissance assymptotique:
	\begin{equation}
		n^{\sqrt{n}}, n\cdot log(n), n^{1/log(n)}, log(log(n)), \sqrt{n}, 3^{n}/{n^5}, 2^n
	\end{equation}

	\begin{note}{Alpha}
		Cette question semble peu claire, il serait judicieux d'ajouter des conseils expliquant la croissance de fonctions.
	\end{note}
	
	% Solutions complexité - Etienne
	\begin{solution}
		\begin{itemize}
			\item D'abord la constante : $n^{1/log(n)} = (2^{log(n)})^{1/log(n)}$
			\item Ensuite le $log(log(n))$
			\item Puis $n^{\sqrt{n}} = 2^{\sqrt{n}\cdot log_2(n)}$
			\item Puis $2^n$
			\item Enfin  $3^{n}/{n^5}$
		\end{itemize}
	\end{solution}
\end{Exercice}


% Exercice théorique - Etienne
\begin{Exercice}[20 minutes]\textbf{Arbre binaire}\\
	\begin{enumerate}
		\item Ecrire un programme Python ayant une complexité temporelle de $O(log n)$ qui prend comme argument un tableau trié \lstinline{A[1, ..., n]} de $n$ nombres et une clé $k$ et qui retourne \textbf{"OUI"} si \lstinline{A} contient $k$ et \textbf{"NON"} dans le cas contraire.
		\item Quelle est la hauteur minimale et la hauteur maximale d'un arbre binaire de recherche ayant $n$ éléments?
		\item Considerer l'arbre binaire suivant : \\
		
		Dessiner les arbres obtenus après executions de chacune des opérations suivantes (chaque opération~est exécutée en commençant par l'arbre ci-dessus - les opérations ne sont pas exécutées de façon séquentielle).
		
		\begin{figure}[h!]
        			\centering
       	 		\includegraphics[width=10cm]{resources/exoArbreBinEnonce.png}
	    	\end{figure}
		\begin{enumerate}
			\item \textsc{Tree-Insert}(T, z) avec z.key = 0
			\item \textsc{Tree-Insert}(T, z) avec z.key = 17
			\item \textsc{Tree-Insert}(T, z) avec z.key = 14
			\item \textsc{Tree-Delete}(T, a)
			\item \textsc{Tree-Delete}(T, b)
			\item \textsc{Tree-Delete}(T, c)
		\end{enumerate}


	\end{enumerate}
	% Solution exercice théorique - Etienne
	\begin{solution}
		\begin{enumerate}
			\item Etant donné que les nombres du tableau A sont triés, nous utilisons l'algorithme de recherche binaire. L'algorithme de recherche binaire  prend comme argument un tableau A, une clé k, des indices p et q et retourne "OUI" si A[p . . . q]  contient la clé k et "NON" autrement. Comme A[p . . . q] est trié, nous pouvons comparer k avec l'élément du milieu mid = $\lfloor(p+q)//2\rfloor$  et : \\
				\begin{itemize}
					\item Si A[mid] = k return "OUI" \\
					\item Si A[mid] $>$ k, alors cherchons k dans le tableau A[p . . . (mid-1)] en appelant récursivement l'algorithme \textsc{Binary-Search}(A, k, p, mid-1) \\
					\item Si A[mid] $<$ k, alors cherchons k dans le tableau A[(mid + 1) . . . q] en appelant récursivement l'algorithme \textsc{Binary-Search}(A, k, mid+1, q)\\
				\end{itemize}
				Le programme permettant d'effectuer une recherche binaire est le suivant:
				\lstinputlisting{solutions/exerciseTheorieBinarySearch.py}
				% Note that we solve the original problem by calling \textsc{Binary-Search}(A, k, 1, n).
			\item Hauteur minimale et maximale d'un arbre binaire.
				\begin{itemize}
					\item La hauteur maximale d'un arbre binaire est atteinte quand l'arbre n'est constitué que d'une seule branche. \\
					
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/maxHeight.png}
	    					%\end{figure}
					\item La hauteur minimum est atteinte lorsque l'arbre binaire est "complet" : nous ne pouvons pas ajouter de noeud sans augmenter la hauteur de l'arbre hauteur de un. \\
					% TODO: @Etienne - Je ne suis pas sûr d'avoir compris cette question. L'ont-ils vu en cours? 
					
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/min_height.png}
	    					%\end{figure}
				\end{itemize}
			\item Après execution de chaque opération, nous obtenons:
				\begin{enumerate}
					\item Figure A : \textsc{Tree-Insert}(T, z) avec z.key = 0
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/exoBTFigA.png}
	    					%\end{figure}
					\item Figure B : \textsc{Tree-Insert}(T, z) avec z.key = 17
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/exoBTFigB.png}
	    					%\end{figure}
					\item Figure C: \textsc{Tree-Insert}(T, z) avec z.key = 14
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/exoBTFigC.png}
	    					%\end{figure}
					\item Figure D : \textsc{Tree-Delete}(T, a)
						%\begin{figure}[h!]
        						%	\centering
						%	\includegraphics[width=6cm]{solutions/exoBTFigD.png}
	    					%\end{figure}
					\item Figure E : \textsc{Tree-Delete}(T, b)
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/exoBTFigE.png}
	    					%\end{figure}
					\item Figure F : \textsc{Tree-Delete}(T, c)
						%\begin{figure}[h!]
        						%	\centering
       	 					%	\includegraphics[width=6cm]{solutions/exoBTFigF.png}
	    					%\end{figure}
			\end{enumerate}
		\end{enumerate}
	\end{solution}

	\begin{solution}
		\centering
		\includegraphics[width=9cm]{solutions/tree_merged.jpg}
	\end{solution}
		
\end{Exercice}


% Exercice BFS Papier - Sarra
\begin{Exercice}[5 minutes]\textbf{Breadth-First Search : Papier
}\\
\\
	Le but du Breadth-first search (BFS) ou parcours en largeur est d'explorer un graphe à partir d’un sommet donné (sommet de départ ou sommet source). \\

	Appliquez l’algorithme \lstinline{BFS} au graphe suivant :\\

	\begin{figure}[h!]
        		\centering
       	 	\includegraphics[]{resources/exerciceBFS.png}
	\end{figure}


	% Solution BFS - Sarra
	\begin{solution}
		\includegraphics[width=10cm]{solutions/BFS1.PNG}\\
		\includegraphics[width=10cm]{solutions/BFS2.PNG}\\
 		Ci-dessous l'arborescence associée au parcours.\\
		\includegraphics[]{solutions/BFS3.PNG}\\
		L’ordre de parcours est : ligne après ligne (de la racine vers les feuilles) et
		de gauche à droite pour une ligne.
	\end{solution}
\end{Exercice}

% Exercice BFS Python - Sarra
\begin{Exercice}[15 minutes]\textbf{Breadth-First Search : Python
}\\
	Dans cet exercice, nous aimerions identifier le chemin le plus court entre deux nœuds d'un graphe.
	La fonction que nous implémentons doit pouvoir accepter comme argument un graphe, un nœud de départ et un nœud de fin. Si l'algorithme est capable de connecter les nœuds 			de départ et d'arrivée, il doit renvoyer le chemin. nous allons utiliser l'algorithme BFS car il renvoie toujours le chemin le plus court.\\
	\begin{note}{Alpha}
		À cet endroit, on devrait ajouter le pseudo-code permettant d'implémenter l'algorithme.
	\end{note}

	\lstinputlisting[language=python]{resources/bfs_enonce.py}
    	\begin{conseil}
		Il existe quelques différences principales entre l'implémentation e de BFS pour l'application du plus court chemin.
		% TODO: Sarra - cette phrase semble incomplète.
        		\begin{enumerate}
			\item La file d'attente garde une trace des chemins possibles (implémentés sous forme de liste de nœuds) au lieu des nœuds.
	           	\item lorsque l'algorithme recherche un nœud voisin, il doit vérifier si le nœud voisin correspond au nœud cible. Si c'est le cas, nous avons une solution et il n'est pas 					nécessaire de continuer à explorer le graphique.
        		\end{enumerate}

    	\end{conseil}

	% Solution BFS - Sarra
	\begin{solution}
		\lstinputlisting{solutions/bfs_shortest_path.py}
	\end{solution}
\end{Exercice}

% Exercice Kruskal Papier - Sarra
\begin{Exercice}[5 minutes] \textbf{Algorithme de Kruskal : Papier}\\
\\
    	Appliquez l'algorithme de Kruskal au graphe suivant :\\
	
	\centering
    	\includegraphics[]{resources/exerciceKruskal.PNG}
    	\begin{conseil}
        		L'algorithme de Kruskal fonctionne de la façon suivante :
        		\begin{enumerate}
		            \item Classer les arêtes par ordre croissant de poids.
		            \item Prendre l'arête avec le poids le plus faible et l'ajouter à l'arbre (si 2 arêtes ont le même poids, choisir arbitrairement une des 2).
		            \item Vérifiez que l'arête ajoutée ne crée pas de cycle, si c'est le cas, supprimez la.
		            \item Répétez les étapes 2) et 3) jusqu'à ce que tous les sommets aient été atteints.
	        \end{enumerate}
	        Un Minimum Spanning Tree, s'il existe, a toujours un nombre d'arêtes égal au nombre de sommets moins un. Par exemple, ici notre graphe a 9 sommets. L'algorithme devrait donc 			s'arrêter lorsque 8 arêtes ont été choisies.
    	\end{conseil}
    \begin{solution}
        Vous trouverez ci-dessous les étapes de la construction du MST(Minimum spanning tree) avec l'algorithme de Kruskal :\\
        \includegraphics[width=13cm]{solutions/K1.PNG}\\
        \includegraphics[width=13cm]{solutions/K2.PNG}\\
        L'algorithme s'arrête car tous les sommets ont été atteints. On voit bien que seules 8 arêtes ont été nécessaires.
      
    \end{solution}

\end{Exercice}

\end{document}