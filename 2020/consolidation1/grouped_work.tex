\input{../header.tex}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Consolidation 1}


Le code présenté dans les énoncés se trouve sur Moodle, dans le dossier \lstinline{Ressources}.


\section{Introduction et architecture des ordinateurs}

\subsection{Introduction/Résumé}

Le but de cette séance est de comprendre le fonctionnement d'un ordinateur. La série d'exercices sera axée autour de de conversions en base binaire, décimale ou hexadécimal, de calcul de base en suivant le modèle Von Neumann. \\

\subsection{Conversion}

\begin{Exercice}[10 minutes]  \textbf{Conversion }\\
    \begin{enumerate}
        \item Convertir le nombre FFFFFF$_{(16)}$ en base 10.
        \item Convertir le nombre 4321$_{(5)}$ en base 10.
        \item Convertir le nombre ABC$_{(16)}$ en base 2.
        \item Convertir le nombre 254$_{(10)}$ en base 15.
        \item Convertir le nombre 11101$_{(2)}$ en base 10.
    \end{enumerate}
    
        \begin{conseil}
            N'oubliez pas qu'en Hexadécimal, A vaut 10, B vaut 11, C vaut 12, D vaut 13, E vaut 14 et F vaut 15.
    \end{conseil}

    \begin{solution}
        1. FFFFFF$_{(16)}$ = 16777215$_{(10)}$\\
        2. 4321$_{(5)}$ = 586$_{(10)}$\\
        3. ABC$_{(16)}$ = 101010111100$_{(2)}$\\
        4. 254$_{(10)}$ = 11E$_{(15)}$\\
        5. 11101$_{(2)}$ = 29$_{(10)}$
    \end{solution}
\end{Exercice}

\begin{comment}
    % Les étudiants n'ont pas rencontré de difficultés sur des exercices similaires
\subsection{Arithmétique binaire}

\begin{Exercice}[5 minutes] \textbf{Addition et soustraction de nombres binaires}
    \begin{enumerate}
        \item Additionner \lstinline{10110101}$_{(2)}$ et \lstinline{00010101}$_{(2)}$
        \item Soustraire \lstinline{11000101}$_{(2)}$ et \lstinline{01000000}$_{(2)}$

    \end{enumerate}
    
     \begin{conseil}
        Cf: exercice 4,5 week 1
    \end{conseil}
    
  

    \begin{solution}
        1. {10110101}$_{(2)}$ + {00010101}$_{(2)}$ = {11001010}$_{(2)}$\\
        2. {11000101}$_{(2)}$ - {01000000}$_{(2)}$ = {10000101}$_{(2)}$
    \end{solution}
\end{Exercice}








\end{comment}
\subsection{Conversion et arithmétique}
\begin{Exercice}[5 minutes] \textbf{Conversion, addition et soustraction:}\\
    Effectuer les opérations suivantes:
    \begin{enumerate}
        \item 10110101$_{(2)}$ + 00101010$_{(2)}$ = ...$_{(10)}$
        \item 70$_{(10)}$ - 10101010$_{(2)}$ = ...$_{(10)}$
    \end{enumerate}
        \begin{conseil}
        Convertissez dans une base commune avant d'effectuer les opérations.
    \end{conseil}
        
    \begin{solution}
        1. 10110101$_{(2)}$ + 00101010$_{(2)}$ = 202$_{(10)}$\\
        3. 70$_{(10)}$ - 10101010$_{(2)}$ = 240$_{(10)}$
    \end{solution}
\end{Exercice}


\subsection{Modèle de Von Neuman}
Dans cette section, nous allons simuler une opération d'addition dans le \textbf{modèle de Van Neumann}, il va vous être demandé à chaque étape (FDES) de donner la valeur des registres.\\

\textbf{État d'origine:}\\
A l'origine, notre \lstinline{Process Counter (PC)} vaut \lstinline{00100001}.\\

Dans la mémoire, les instructions sont les suivantes:

\begin{tabular}{| C{0.1\textwidth} | C{0.1\textwidth} |} 
    \hline
    \textbf{Adresse} & \textbf{Valeur}\\ [0.5ex]
    \hline
    00100001 & 00110100\\ [0.5ex] 
    \hline
    00101100 & 10100110\\ [0.5ex] 
    \hline
    01110001 & 111111101\\ [0.5ex]
    \hline
\end{tabular}
\\\\
Les registres sont les suivants:

\begin{tabular}{| C{0.1\textwidth} | C{0.1\textwidth} |} 
    \hline
    \textbf{Registre} & \textbf{Valeur}\\ [0.5ex]
    \hline
    00 & 01111111\\ [0.5ex] 
    \hline
    01 & 00100000\\ [0.5ex] 
    \hline
    10 & 00101101\\ [0.5ex] 
    \hline
    11 & 00001100\\ [0.5ex]
    \hline
\end{tabular}
\\\\
Les opérations disponibles pour l'unité de contrôle sont les suivantes:
\\
\begin{tabular}{| C{0.1\textwidth} | C{0.1\textwidth} |} 
    \hline
    \textbf{Numéro} & \textbf{Valeur}\\ [0.5ex]
    \hline
    00 & ADD\\ [0.5ex] 
    \hline
    01 & XOR\\ [0.5ex] 
    \hline
    10 & MOV\\ [0.5ex] 
    \hline
    11 & SUB\\ [0.5ex]
    \hline
\end{tabular}
\\\\


\begin{Exercice}[5 minutes]\textbf{Fetch}\\
    À la fin de l'opération \lstinline{FETCH}, quelles sont les valeurs du \lstinline{Process Counter} et de l'\lstinline{Instruction Register}?
\end{Exercice}
   \begin{conseil}
    Pour rappel, l’unité de contrôle (Control Unit) commande et contrôle le fonctionnement du système. Elle est chargée du séquençage des opérations. Après chaque opération FETCH, la valeur du Program Counter est incrémentée (valeur initiale + 1).
    \end{conseil}
\begin{solution}
    PC = 00100001$_{(2)}$ + 1 = 00100010$_{(2)}$\\
    IR = 00110100$_{(2)}$
\end{solution}

\begin{Exercice}[5 minutes] \textbf{Decode}
    \begin{enumerate}
        \item Quelle est la valeur de l'opération à exécuter?
        \item Quelle est l'adresse du registre dans lequel le résultat doit être enregistré?
        \item Quelle est la valeur du premier nombre de l'opération?
        \item Quelle est la valeur du deuxième nombre de l'opération?
    \end{enumerate}
\end{Exercice}
   \begin{conseil}
    Pensez à décomposer la valeur de l’Instruction Register pour obtenir toutes les informations demandées.\\
    Utilisez la même convention que celle présentée dans les diapositives du cours (Architecture des ordinateurs (Semaine 2) - Diapositive 15)\\
    Les données issues de la décomposition de l’\lstinline{Instruction Register} ne sont pas des valeurs brutes, mais des références. Trouvez les tables concordantes pour y récupérer les valeurs.

    \end{conseil}
\begin{solution}
    00 : \lstinline{ADD} (valeur de l'opération à exécuter)\\
    11 : Adresse du registre dans lequel le résultat doit être enregistré\\
    01 : 00100000$_{(2)}$ (premier nombre)\\
    00 : 01111111$_{(2)}$ (deuxième nombre)
\end{solution}

\begin{Exercice}[5 minutes] \textbf{Execute}\\
    Quel est résultat de l'opération?
\end{Exercice}

   \begin{conseil}
        Toutes les informations permettant d’effectuer l’opération se trouvent dans les données de l’\lstinline{Instruction Register}.
    \end{conseil}

\begin{solution}
    00100000$_{(2)}$ + 01111111$_{(2)}$ = 10011111$_{(2)}$
\end{solution}


% Week 2
\section{Logiciels système}

\subsection{Introduction/Résumé}

\subsection{Operating system}

\begin{Exercice}[5 minutes]
    Sous Linux et MacOS, laquelle de ces commandes modifie le \lstinline{filesystem}?
    \begin{enumerate}
        \item \lstinline{ls -la}
        \item \lstinline{sudo rm -rf ~/nano}
        \item \lstinline{sudo kill -9 3531}
        \item \lstinline{more nano.txt}
        \item Aucune réponse n'est correcte.
    \end{enumerate}
    \begin{solution}
        La commande \lstinline{sudo rm -rf ~/nano} permet de supprimer le répertoire \lstinline{nano} situé dans le dossier \lstinline{/Users/<Utilisateur\_courant>} en mode super-utilisateur (utilisateur ayant des droits étendus sur le système).
    \end{solution}
    \begin{conseil}
        \textbf{Attention!}Certaines commandes listées ci-dessus peuvent avoir des conséquences irréversibles.\\
        Pour avoir une description détaillée d'une commande, vous pouvez ajouter \lstinline{man} devant chaque commande sous Linux/MacOS ou ajouter \lstinline{-h, --help} ou \lstinline{/?} après chaque commande sous Windows.
    \end{conseil}
\end{Exercice}

% Week 3
\section{Programmation de base}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[Durée 5]\\
    \begin{enumerate}
        \item Convertir 52$_{(10)}$ en base 2 sur 8 bits.
        \item Convertir 100$_{(10)}$ en base 2 sur 8 bits.
        \item Calculer en base 2 la soustraction de la question de l'exercice 1.2 par 1.1.
        \item Déterminer au complément à deux l'opposé ( multiplication par -1 en base 10) de l'exercice 3.3.
    \end{enumerate}
\begin{conseil}
   % Un conseil
   \begin{itemize}
       \item Se référer aux techniques apprises dans la série 1 et la série 3
       \item Faire un tableau des puissances de 2 sur 8 bits.
   \end{itemize}
\end{conseil}
    
\begin{solution}
\begin{itemize}
    \item 52$_{(10)}$ = 32$_{(10)}$ + 16$_{(10)}$ + 4$_{(10)}$ = 00110100$_{(2)}$
    \item 100$_{(10)}$ = 64$_{(10)}$ + 32$_{(10)}$ + 4$_{(10)}$ = 01100100$_{(2)}$
    \item 01100100$_{(2)}$ - 00110100$_{(2)}$ = 0110000$_{(2)}$
    \item \textbf{Complément à 1:} not(0110000$_{(2)}$) = 1001111$_{(2)}$ 
    \item \textbf{Complément à 2:} Complément à 1 + 1 = 1001111$_{(2)}$ + 1$_{(2)}$ = 1010000$_{(2)}$
    %\lstinputlisting{solutions/fichier.java}
\end{itemize}   
\end{solution}

\end{Exercice}



% Week 4
\section{Itération et récursivité}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[15 min] Itération et Récursivité\\

Créez une fonction itérative, puis une fonction récursive qui calculent le nombre de voyelles présentes dans un texte donné. \\

\begin{conseil}
   Pour la version itérative, parcourez toute la chaine de caractère et incrémentez un compteur lorsque vous avez une voyelle.
   
   Pour la version récursive, diminuez systématiquement la taille de votre chaine de caractère. Si l'élément actuel est une voyelle, ajoutez 1, ajoutez 0 sinon.
   
   Aidez vous d'une liste de toutes les voyelles et de la fonction \lstinline{in} en \lstinline{Python} (\lstinline{List.contains()} en \lstinline{Java}).
\end{conseil}

Voici les templates : \\

\textbf{Python} \\

	\lstinputlisting{exercices/iteration_recursion_exercice.py} 

\textbf{Java} \\

	\lstinputlisting{exercices/iteration_recursion_exercice.java}

    
\begin{solution}
\textbf{Python :} \\

    \lstinputlisting{solutions/iteration_recursion_solution.py}
    
\end{solution}


\begin{solution}   
\textbf{Java :} \\

    \lstinputlisting{solutions/iteration_recursion_solution.java}
    
    
    
\end{solution}

\end{Exercice}

\begin{Exercice}[5 min] Lecture de code (Récursivité)\\

Qu' afficheront les deux codes suivants ? \\

\begin{conseil}
   Ces deux codes comportent des fonctions itératives, lisez bien le code de haut en bas et lorsque la fonction s'auto-appelle, revenez au début de cette fonction et réeffectuez les instructions avec les nouveaux paramètres.
   
   Une feuille de papier pourrait vous aider !
\end{conseil}

Voici les codes à lire : \\

\textbf{Code 1 :} \\

	\lstinputlisting{exercices/recursion_1_exercice.py} 

\textbf{code 2 :} \\

	\lstinputlisting{exercices/recursion_2_exercice.py}

    
\begin{solution}
\textbf{Code 1 :} \\

    Python
    
	adore
	
	Python
	
	J
	
	Python
	
	adore
	
	Python

    
\end{solution}


\begin{solution}   
\textbf{Code 2 :} \\

    PythonohtyP
    
\end{solution}

\end{Exercice}


\begin{Exercice}[5 min] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}

% Week 5
\section{Algorithmes et compléxité}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[5 min] Compléxité - Partie 1\\
    Énumérer le nombre d'opérations qu'effectue l'algorithme ci-dessous à chaque étape:
    \lstinputlisting{exercices/week5_algo1_complexite.py}
\begin{conseil}
   Les opérations dans une boucle \lstinline{for} sont répétées autant de fois que le 
   nombre d'éléments sur lesquels nous itérons.
\end{conseil}
    
\begin{solution}
L'algorithme effectue 1 opération pour initialiser $n$ à \lstinline{len(L)}. Ensuite, l'algorithme
effectue une boucle for qui itère sur $n$ éléments. Dans la boucle for, l'algorithmes éxécute deux additions.
Ainsi, nous avons au total : $1 + 2\times n$ opérations. \\
En notation $O()$, nous avons une compléxité de : $O(2*n + 1) = O(n)$ car les constantes sont ignorées.    
\end{solution}

\end{Exercice}

\begin{Exercice}[5 min] Compléxité - Partie 2\\
    Énumérer le nombre d'opérations qu'effectue l'algorithme ci-dessous à chaque étape:
    \lstinputlisting{exercices/week5_algo2_complexite.py}
\begin{conseil}
   Les opérations dans une boucle \lstinline{for} sont répétées autant de fois que le 
   nombre d'éléments sur lesquels nous itérons.
\end{conseil}
    
\begin{solution}
    L'algorithme vérifie si la liste contient des doublons.
    \begin{enumerate}
        \item L'algorithme effectue 1 opération pour initialiser $n$ à \lstinline{len(L)}. 
        \item Ensuite, l'algorithme effectue 2 boucles for imbriquées qui itère chacune sur $n$ éléments. 
        \item Dans la deuxième boucle for, l'algorithmes éxécute deux comparaisons. 
        Ainsi, nous avons au total : $1 + 2 \times n^2$ opérations. \\
    \end{enumerate}
    En notation $O()$, nous avons une compléxité de : $O(2n^2 + 1) = O(n^2)$ car les constantes sont ignorées. 
       
\end{solution}

\end{Exercice}

\begin{Exercice} [15 minutes] \textbf{Tri fusion (Merge Sort)}
    \begin{enumerate}
        \item  Ecrire un fonction "merge" qui prend deux listes triées comme argument et retourne une liste fusionnée triée.
        \item Quelle est le nombre d'opérations effectuées ? Déterminer ensuite la complexité de la fonction, en posant n = longueur de la liste fusionnée
    \end{enumerate}
       
       Pour les tests utilisez les listes suivantes:\\ \lstinline{l1}  [3,10,12] et 
       \lstinline{l2}  [5,7,14,15]
    \begin{conseil}
    \begin{itemize}
        \item Cette fonction est une des deux parties de l'algorithme de tri fusion
        \item Revenez à l'exercice 11 de la série 5. 
        \item Revenez à la visualisation de l'algorithme dans les diapositives 83 à 111 pour comprendre comment marche concrètement le tri fusion. 
    \end{itemize}
    \end{conseil}
    \begin{solution}
        \textbf{Python :}
         \lstinputlisting{solutions/question_mergesort_conso1.py}
    \end{solution}
    
    \begin{solution}
        \textbf{Java :}
         \lstinputlisting{solutions/question_conso1_mergesort.java}
    \end{solution}
    \begin{solution}
    \begin{itemize}
    \item \textbf{En python il y a:} n = 3+ 4 = 7 itérations. Les opérations avant et après la boucle sont des opérations simples, donc la complexité "pire cas" est calculé grâce à la boucle while et donc en fonction de la taille de la liste finale.
    \item \textbf{En java il y a:} n = 3 + 2 itérations effectuées dans la première boucle while. \\ Dans la deuxième boucle while il y a uniquement m = 2 itérations effectuées. Les boucles n'étant pas imbriquées les complexités s'additionnent. 
    \item Donc la complexité est O ( n + m) car cela va dépendre de la grandeur des listes rentrées en argument.
    \end{itemize}
    \end{solution}
\end{Exercice}

% Week 6
\section{Algorithmes de recherche}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[20min] Recherche binaire \\

Dans cet exercice, vous devrez retrouver l'élément d'une liste d'entiers triés qui est le plus proche d'un élément e donné. Pour ce faire, vous devrez utiliser une version récursive de l'algorithme de recherche binaire.\\

Exemple:\\

\lstinline{L = [1, 11, 22, 33, 44, 55, 66, 77, 88, 99]}\\
\lstinline{e = 73}\\\\
\lstinline{print(plus proche(L, e, recherche binaire recursive(L, 0, len(L)-1, e)))}\\

Résultat attendu: 77\\

\begin{conseil}
   Dans cet exercice, vous devrez déclarer deux fonctions, et les combiner afin de retrouver l'élément de la liste qui est le plus proche de \lstinline{e}. \\
   
   La première fonction sera la fonction de recherche binaire récursive qui prendra en paramètre la liste, l'index du premier élément de la liste, l'index du dernier élément de la liste et e. Cette fonction retournera l'index de l'un des éléments le plus proche de e. 
   La deuxième fonction effectuera les comparaisons de différences entre e et les éléments se situant autour de l'élément correspondant à l'index retourné par la première fonction. Elle pourra ainsi déterminer lequel est le plus proche de e. Elle prendra en paramètre notre liste, e, et la valeur retournée par la première fonction. \\
\end{conseil}

Voici les templates : \\

\textbf{Python} \\

	\lstinputlisting{exercices/binary_search_closest_exercice.py} 

\textbf{Java} \\

	\lstinputlisting{exercices/binary_search_closest_exercice.java}

    
\begin{solution}
\textbf{Python :} \\

    \lstinputlisting{solutions/binary_search_closest_solution.py}
    
\end{solution}


\begin{solution}   
\textbf{Java :} \\

    \lstinputlisting{solutions/binary_search_closest_solution.java}
    
    
    
\end{solution}

\end{Exercice}

\section{Quizz général}

\subsection{Python}

\begin{Exercice}[2 minutes] Exercice 1\\
En python, 'Hello' équivaut à "Hello". 

\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Vrai}: En python, les doubles guillemets et les guillemet sont équivalents. 
\end{solution}
\end{Exercice}


\begin{Exercice}[2 minutes] Exercice 1\\
À la fin d'une fonction, nous pouvons utiliser les commandes \lstinline{print()} ou \lstinline{return}, elles ont la même utilité.
\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Faux}\\
    \lstinline{print()} permet uniquement d'afficher un message dans la console. Autrement dit, \lstinline{print()} sert à communiquer un message à l'utilisateur final du programme, celui-ci n'ayant pas accès au code.\\\\
    \lstinline{return} est une déclaration qui s'utilise à l'intérieur d'une fonction pour renvoyer le résultat de la fonction lorsqu'elle a été appellée. Exemple: la fonction \lstinline{len(L)} renvoie la longeur de la liste L.
\end{solution}
\end{Exercice}


\begin{Exercice}[2 minutes] Exercice 1\\
Lorsque l'on fait appel à une fonction, les arguements doivent nécessairement avoir le(s) même(s) noms tel(s) que définit dans la fonction. Exemple:\\
\begin{lstlisting}
def recherche_lineaire(Liste, x):
    for i in Liste:
        if i == x:
            return x in Liste
    return -1

Liste = [1,3,5,7,9]
x = 3

recherche_lineaire(Liste,x)

\end{lstlisting}
\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Faux}\\
    Le noms des variables données en argument n'a aucune importance tant que le type de variable est respecté. Dans notre exemple, la fonction attend s'attend à une \textbf{liste} en premier argument et un \textbf{entier} en deuxième argument. Ici, nous aurions pu nommer la liste \lstinline{"nbr_impair"} et x \lstinline{"valeur"} et ainsi appelé la fonction \lstinline{recherche_lineaire(nbr_impair, valeur)}

\end{solution}
\end{Exercice}

\begin{Exercice}[2 minutes] Exercice 1\\
Si le programme python contient une erreur, celle-ci sera detectée avant l'exécution du programme. 

\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Faux}: En python, les erreurs sont détectées pendant l'exécution du programme.
\end{solution}
\end{Exercice}


\begin{Exercice}[2 minutes] Exercice 1\\
Il est possible de faire appel à une fonction définie "plus bas" dans le code sans que cela ne pose problème.

\begin{lstlisting}
import math

nombre_decimal_pi(4)

def nombre_decimal_pi(int):
    return round(math.pi,int)
\end{lstlisting}

\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Faux}: À l'excéption des fonctions intégrées (il s'agit des fonctions déjà intégrées au language python telles que \lstinline{print(), len(), abs(), etc}... une fonction doit nécessairement être définie \textbf{avant} d'être appellée.
\end{solution}
\end{Exercice}


\begin{Exercice}[5 minutes] Exercice 1\\
Les trois fonctions suivantes renvoient-elles systématiquement des résultats identiques ?\\Les fonctions sont censées retourner le nombre pi avec le nombre de décimales (au moins une et au maximum 15) indiqué en paramètre.
\begin{multicols}{3}
\begin{lstlisting}
import math

def nombre_decimal_pi(int):
    if int > 15:
        int = 15
    elif int < 0:
        int = 1
    resultat = round(math.pi,int) 
    return resultat

print(nombre_decimal_pi(-2))
print(nombre_decimal_pi(4))
print(nombre_decimal_pi(20))



\end{lstlisting}
\columnbreak

\begin{lstlisting}
import math

def nombre_decimal_pi(int):
    if int > 15:
        resultat = round(math.pi,15)
    elif int < 0:
        resultat = round(math.pi,1)
    else: 
        resultat = round(math.pi,int)
    return resultat

print(nombre_decimal_pi(-2))
print(nombre_decimal_pi(4))
print(nombre_decimal_pi(20))

\end{lstlisting}
\columnbreak

\begin{lstlisting}
import math

def nombre_decimal_pi(int):
    if int > 15:
        return round(math.pi,15)
    elif int < 0:
        return round(math.pi,1)
    else: 
        return round(math.pi,int)
    

print(nombre_decimal_pi(-2))
print(nombre_decimal_pi(4))
print(nombre_decimal_pi(20))

\end{lstlisting}
\end{multicols}

\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Vrai}: Les trois fonctions produisent des résultats identiques. Si besoin, exécutez le code dans IntelliJ.
\end{solution}
\end{Exercice}



\subsection{Java}


\begin{Exercice}[3 minutes] Exercice 1\\
Observez les deux codes suivants en java. Lequel a-t-il la bonne structure et peut être compilé sans erreur ?

\begin{multicols}{2}
\begin{lstlisting}
//Code A
public class Main {

    public static void main(String[] args) {
        ma_function();
        autre_fonction();
    

        static void ma_function(){
            System.out.println("Voici ma fonction!");
        }
    
        static void autre_fonction(){
            System.out.println("Une autre fonction!");
        }
    }
}



\end{lstlisting}
\columnbreak

\begin{lstlisting}
//Code B
public class Main {

    public static void main(String[] args) {
    ma_function();
    autre_fonction();
    }

    static void ma_function(){
        System.out.println("Voici ma fonction!");
    }

    static void autre_fonction(){
        System.out.println("Une autre fonction!");
    }
}
\end{lstlisting}
\columnbreak

\end{multicols}
\begin{enumerate}[label=\Alph*]
    \item (à gauche)
    \item (à droite)
\end{enumerate}
\begin{solution}
    \textbf{Le code B}\\
    Le fichier dans son ensmble représente une \lstinline{class} java, ici la class s'appelle \textbf{Main}. À l'intérieur de cette class se trouve la fonction \lstinline{public static void main()}, il s'agit de fonction principale du programme, celle que l'on exécute et celle dans laquelle nous rédigeons notre code.\\
    Les autres fonctions, qui peuvent être appellées, se définissent au sein de la classe au même échelon que la fonction \lstinline{public static void main()} comme dans le Code B ci-dessus. 
\end{solution}
\end{Exercice}

\begin{Exercice}[2 minutes] Exercice 1\\
L'indentation des lignes de code en java est aussi importante qu'en python.
\begin{enumerate}[label=\Alph*]
    \item - Vrai
    \item - Faux
\end{enumerate}
\begin{solution}
    \textbf{Faux}
    \\En java, le compilateur ne prend pas en compte l'indentation pour interprété le programme, il comprend la structure à l'aide des parenthèses, des accolades et encore des point-virgule qui indique la fin d'une commande. Toutefois, l'indentation est un aspect important de la programmation car elle sert à bien structurer visuellement votre code.\\\\
    En python, l'indentation défini la structure de votre code. Elle est donc indispensable pour la bonne interprétation et la bonne exécution de votre programme. 
\end{solution}
\end{Exercice}


\end{document}
