\input{../header.tex}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Algorithmes de recherche}


\begin{comment}
\begin{enumerate}
    \item Recherche séquentielle
    \item Recherche binaire
    \item Arbres de recherche binaire\\
\end{enumerate}
\end{comment}

Le but de cette séance est de se familiariser avec les algorithmes de recherche. Dans la série d'exercices, nous manipulerons des listes et collections en Java et Python. Nous reviendrons sur la notion de récursivité et découvrirons les arbres de recherche. Au terme de cette séance, l'étudiant sera en mesure d'effectuer des recherches de façon efficiente sur un ensemble de données.

Le code présenté dans les énoncés se trouve sur Moodle, dans le dossier \lstinline{Ressources}.


\section{Introduction et architecture des ordinateurs}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[Durée] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}


% Week 2
\section{Logiciels système}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[Durée] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}

% Week 3
\section{Programmation de base}

\subsection{Introduction/Résumé}

\subsection{Exercices}
    
\begin{Exercice}[Durée 5]\\
    \begin{enumerate}
        \item Convertir 52$_{(10)}$ en base 2 sur 8 bits.
        \item Convertir 100$_{(10)}$ en base 2 sur 8 bits.
        \item Calculer en base 2 la soustraction de la question de l'exercice 1.2 par 1.1.
        \item Déterminer au complément à deux l'opposé ( multiplication par -1 en base 10) de l'exercice 3.3.
    \end{enumerate}
\begin{conseil}
   % Un conseil
   \begin{itemize}
       \item Se référer aux techniques apprises dans la série 1 et la série 3
       \item Faire un tableau des puissances de 2 sur 8 bits.
   \end{itemize}
\end{conseil}
    
\begin{solution}
\begin{itemize}
    \item 52$_{(10)}$ = 32$_{(10)}$ + 16$_{(10)}$ + 4$_{(10)}$ = 00110100$_{(2)}$
    \item 100$_{(10)}$ = 64$_{(10)}$ + 32$_{(10)}$ + 4$_{(10)}$ = 01100100$_{(2)}$
    \item 01100100$_{(2)}$ - 00110100$_{(2)}$ = 0110000$_{(2)}$
    \item \textbf{Complément à 1:} not(0110000$_{(2)}$) = 1001111$_{(2)}$ 
    \item \textbf{Complément à 2:} Complément à 1 + 1 = 1001111$_{(2)}$ + 1$_{(2)}$ = 1010000$_{(2)}$
    %\lstinputlisting{solutions/fichier.java}
\end{itemize}   
\end{solution}

\end{Exercice}

% Week 4
\section{Itération et récursivité}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[Durée] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}

% Week 5
\section{Algorithmes et compléxité}

\subsection{Introduction/Résumé}

\subsection{Exercices}
     \begin{Exercice} [15 minutes] \textbf{Tri fusion (Merge Sort)}
    \begin{enumerate}
        \item  Ecrire un fonction "merge" qui prend deux listes triées comme argument et retourne une liste fusionnée triée.
        \item Quelle est le nombre d'opérations effectuées ? Déterminer ensuite la complexité de la fonction, en posant n = longueur de la liste fusionnée
    \end{enumerate}\\
       
       Pour les tests utilisez les listes suivantes:\\ \lstinline{l1}  [3,10,12] et 
       \lstinline{l2}  [5,7,14,15]
    \begin{conseil}
    \begin{itemize}
        \item Cette fonction est une des deux parties de l'algorithme de tri fusion
        \item Revenez à l'exercice 11 de la série 5. 
        \item Revenez à la visualisation de l'algorithme dans les diapositives 83 à 111 pour comprendre comment marche concrètement le tri fusion. 
    \end{itemize}
    \end{conseil}
    \begin{solution}
        \textbf{Python :}
         \lstinputlisting{question_mergesort_conso1.py}
        \textbf{Java :}
         \lstinputlisting{question_conso1_mergesort.java}
    \end{solution}
    \begin{solution}
    \begin{itemize}
    \item \textbf{En python il y a:} n = 3+ 4 = 7 itérations. Les opérations avant et après la boucle sont des opérations simples, donc la complexité "pire cas" est calculé grâce à la boucle while et donc en fonction de la taille de la liste finale.
    \item \textbf{En java il y a:} n = 3 + 2 itérations effectuées dans la première boucle while. \\ Dans la deuxième boucle while il y a uniquement m = 2 itérations effectuées. Les boucles n'étant pas imbriquées les complexités s'additionnent. 
    \item Donc la complexité est O ( n + m) car cela va dépendre de la grandeur des listes rentrées en argument.
    \end{itemize}
    \end{solution}
\end{Exercice}
    
    
\begin{Exercice}[Durée] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}

% Week 6
\section{Algorithmes de recherche}

\subsection{Introduction/Résumé}

\subsection{Exercices}

\begin{Exercice}[Durée] Exercice 1\\

\begin{conseil}
   % Un conseil
\end{conseil}
    
\begin{solution}
\textbf{Langage utilisé :}
    %\lstinputlisting{solutions/fichier.java}
    
\end{solution}

\end{Exercice}


\end{document}
