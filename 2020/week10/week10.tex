\input{header}
\usepackage{array}
\usepackage{amsmath}
\usepackage{tabto}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}

% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Probabilistic Algorithms}

Le but de cette séance est de comprendre les algorithmes probabilistes. Ceux-ci permettent de résoudre des problèmes complexes de en relativement peu de temps. La contrepartie est que le résultat obtenu est généralement une solution approximée du problème initial. Ils demeurent néanmoins très utile pour beaucoup d'application.

\section{Monte-Carlo}
\begin{Exercice}[10 minutes]\textbf{Un jeu de hasard : Python}\\
Supposez que vous lanciez une pièce de monnaie l fois et que vous voulez calculez la probabilité d'avoir un certains nombre de pile. Vous devez programmer un algorithme probabiliste, permettant de calculer cette probabilité. Pour ce faire, vous devez compléter la fonction \textit{proba(n,l,iter)} contenue dans le fichier Piece.py. La fonction \textit{Piece(l)} permet de créer une liste contenant des 0 et des 1 aléatoirement avec une probabilité $\frac{1}{2}$. Considérez un chiffre 1 comme une réussite (pile) et 0 comme un échec (face).
\\
\begin{conseil}
    Pour estimez empiriquement la probabilité d'un événement, comptez le nombre de fois que l'événement en question se produit en effectuant un nombre d'essai. Puis divisez le nombre d'occurence de l'événement par le nombre total d'essai. Par exemple, si vous vous voulez estimer la probabilité d'obtenir un 2 avec un dé. Lancez le dé 1000 fois, comptez le nombre de fois que vous obtenez 2, et divisez le résultat par 1000.
\end{conseil}
\begin{solution}
    \lstinputlisting[language = python]{Piece_correction.py}
\end{solution}
\end{Exercice}
\newpage
\begin{Exercice}[20 minutes]\textbf{Une approximation de $\pi$ : Python}\\
L'objectif de cet exercice est programmer un algorithme probabiliste permettant d'approximer le chiffre $\pi$. Immaginez un plan en sur lequel $0 < x < 1$ et $0 < y < 1$. Sur ce dernier, nous allons dessiner un quart de cercle centré en (0,0) et avec un rayon de 1. Par conséquent, un point dans cette espace se trouve à l'intérieur du cercle si $x^2 + y^2 < 1$. Vous trouverez ci-dessous un schéma de la situation:
\begin{center}
\includegraphics[]{Cercle.PNG}
\end{center}
La première étape de cette exercice consiste a créer une fonction permettant de déterminer si un point est à l'intérieur (zone rouge) ou a l'extérieur du cercle. Puis, générez 10000 points dans cette espace (x et y devrait appartenir à [0,1]). Pour ce faire, vous pouvez utliser la fonction \textit{random.random()} après avoir importé le module \textbf{random}. Vous pouvez obtenir l'approximation de $\pi$ à partir de la formule suivante : $\pi \approx [\frac{\text{Nombre de point dans le cercle}}{\text{Nombre de point total}}]\cdot 4$. Votre réponse devrait être assez proche du vrai chiffre $\pi$.\\
\begin{conseil}
    La fonction random.random() génère aléatoirement un chiffre compris entre 0 et 1. Etant donné que vous devez simulez des points en 2 dimension, vous devrez utiliser 2 fois cette fonction.
\end{conseil}
\begin{solution}
 \lstinputlisting[language = python]{Pi.py}
\end{solution}

\end{Exercice}

\begin{Exercice}[15 minutes]\textbf{Un exemple simple de la chaîne de Markov}

Les slides nous ont donné un exemple de la chaîne de Markov, mais on peut aussi formaliser le concept avec les notations suivantes.

Un processus est une chaîne de Markov si
\begin{align} 
P\Big(X_{n+1}=j | X_0=i_0, X_1=i_1, ... , X_{n-1}=i_{n-1},X_n=i\Big) = P\left(X_{n+1}=j | X_n=i\right).
\end{align}

Le nombre $P\left(X_{n+1}=j | X_n=i\right)$ est appelé \textit{probabilité de transition} de l'état $i$ à l'état $j$ (en un pas), et on écrit:

\begin{align}
    p_{ij} = P\left(X_{n+1}=j | X_n=i\right)
\end{align}

La matrice $\mathbf{P}$ dont l'élément à l'indice $(i,j)$ est $p_{ij}$ est appelée \textit{matrice de transition}. Si les chaînes sont homogènes, $\mathbf{P}$ a deux propriétés importantes: i, $p_{ij} \geq 0$ et ii, $\sum_i p_{ij} = 1$.

Soit $\mu_n = (\mu_n(1), ..., \mu_n(N))$ un vecteur-ligne, avec $\mu_n(i) = P(X_n=i)$. Soit $\mu_0$ la loi initiale (la loi de $X_0$). En général, on a qu'à connaître $\mu_0$ et $\mathbf{P}$ pour simuler une chaîne de Markov.

Les probabilités marginales sont:
\[ 
\mu_n = \mu_0 \mathbf{P}^n
\]

Et on a ci-dessous un résumé de la terminologie:

\begin{enumerate}
    \item Matrice de transition $\mathbf{P}(i,j) = P(X_{n+1}=j|X_n=i)=p_{ij}$.
    \item Matrice de transition en $n$ pas : $\mathbf{P}_n(i,j) = P(X_{n+m}=j|X_m=j)$.
    \item $\mathbf{P}_n = \mathbf{P}^n$.
    \item Probabilité marginale : $\mu_n(i) = P(X_n = i)$.
    \item $\mu_n = \mu_0 \mathbf{P}^n$
\end{enumerate}

Etant donné que $X_0, X_1, ...$ est une chaîne de Markov avec 3 états $\{0, 1, 2\}$ et la matrice de transition:

\[ 
\mathbf{P} =
\begin{bmatrix}
0.1 & 0.2 & 0.7 \\
0.9 & 0.1 & 0.0 \\
0.1 & 0.8 & 0.1
\end{bmatrix}
\]
Supposons que $\mu_0 = (0.3, \; 0.4, \; 0.3)$. Trouvez $P(X_0 = 0, X_1=1, X_2=2)$ et $P(X_0=0, X_1=1, X_2=1)$.

\begin{conseil}
    Cet exercice vous demande de trouver deux probabilités \textbf{jointes}. Peut-être vous rappelez-vous qu'en général, 
    \[ 
    P(X=x, Y=y) = P(X=x)P(Y=y|X=x).
    \]
    Pouvez-vous le reformuler avec 3 variables (notez bien que $X_0, X_1, ...$ est une chaîne de Markov) et utiliser les définitions ci-dessus pour trouver la réponse?  
\end{conseil}
\begin{solution}
\begin{align}
    P(X_0=0,X_1=1, X_2=2) &= P(X_0 =0)\times p_{01} \times p_{12} = 0.3 \times 0.1 \times 0.7 = 0.021\\
     P(X_0=0,X_1=1, X_2=1)&=P(X_0 =0)\times p_{01} \times p_{11} = 0.3 \times 0.1\times 0.1 = 0.003
\end{align}
\end{solution}
\end{Exercice}

\begin{Exercice}[7 minutes]\textbf{Probabilités marginales}

En utilisant la loi initiale $\mu_0$ et la matrice \textbf{P} de Question 3, trouvez $\mu_1$, $\mu_2$ et $\mu_3$.

\begin{conseil}
    Relisez et familiarisez-vous avec les notations et la terminologie ci-dessus!
\end{conseil}
    
\begin{solution}
\begin{align}
\mu_1 &=
\left(\begin{matrix}
0.42 & 0.34 & 0.24
\end{matrix}\right)\\
\mu_2 &= 
\left(\begin{matrix}
0.37 & 0.31 & 0.32
\end{matrix}\right) \\
\mu_3 &= \left(\begin{matrix}
0.35 & 0.36 & 0.29
\end{matrix}\right)
\end{align}
\end{solution}

\end{Exercice}

\begin{Exercice}[20 minutes]\textbf{Simuler une chaîne de Markov}

Comme déjà mentionné plus haut, la simulation d'une chaîne de Markov ($X_0, X_1, ...$) exige seulement deux éléments: la loi initiale $\mu_0$ et la matrice de transition $\mathbf{P}$. Spécifiquement, l'algorithme est:

\begin{enumerate}
    \item Supposer que $X_0 \sim \mu_0$. Donc, $P(X_0=i)=\mu_0(i)$.
    \item Le résultat de l'étape 1 est donc $i$; obtenir $X_1 \sim \mathbf{P}$ i.e $P(X_1=j|X_0=i)=p_{ij}$.
    \item Le résultat de l'étape 2 est $j$; obtenir $X_2 \sim \mathbf{P}$ i.e $P(X_2=k|X_1=j)=p_{jk}$.
    \item Répéter jusqu'à la fin (nombre d'iterations est arbitraire).
\end{enumerate}

Ecrivez une fonction simple afin d'implémenter l'algorithme ci-dessus. Nommez-la \textbf{sim\_markov()}, celle-ci prend comme parametres \textbf{P}, \textbf{mu\_0} et \textbf{n\_iters}.
\lstinputlisting[language=python]{SimMarkov_temp.py}


\begin{conseil}
    La méthode \textbf{random.choices()} s'avéra utile!
\end{conseil}
\begin{solution}
\lstinputlisting[language = python]{SimMarkov.py}
\end{solution}
\end{Exercice}

\begin{Exercice}[20 minutes]\textbf{Insertion dans une Treap}
    Une Treap est un arbre binaire où chaque sommet $v$ a 2 valeurs, une clé \lstinline{v.key} et une priorité \lstinline{v.priority}. Une treap estimer
    un arbre de recherche binaire en ce qui concerne les valeurs clés et une heap en ce qui concerne les valeurs prioritaires. \\

    Dans cet exercice, vous allez implémenter une fonction pour insérer un noeud dans une treap. Vous avez le squellette de code suivant à remplir.
    \lstinputlisting[language = python]{treap.py}

    \begin{conseil}
        La fonction \lstinline{insertNode} est récursive. Inspirez-vous de l'insertion dans un arbre de recherche binaire, mais 
        n'oubliez de vérifier que la propriété de la heap est satisfaite après avoir insérer. \\
        La propriété de la heap à satisfaire est que la priorité de la racine doit toujours être plus grande que celle de ses noeuds enfants.
        \lstinline{rotateLeft} et \lstinline{rotateRight} permettent de réarranger les noeuds de façon à ce que la propriété
        de la heap soit satisfaite. Vous pouvez vous réferer à l'illustration ci-dessous pour avoir une idée de comment fonctionne les rotations.
    \end{conseil}

    \begin{center}
        \includegraphics[width=\linewidth]{treap_heap_property.png}
    \end{center}

    \begin{solution}
    \lstinputlisting[language = python]{treap_solution_1.py}
    \end{solution}
    \begin{solution}
        \lstinputlisting[language = python]{treap_solution_2.py}
    \end{solution}
    
\end{Exercice}

\begin{Exercice}[20 minutes]\textbf{Fingerprinting: Une mission pour l'agente secrète Alice}
    Dans cet exercice, vous prendrez le rôle de l'agente secrète Alice. Cette dernière enquêtait sur la disparition de son collègue,
    l'agent Bob, et se doutait que l'indice clé qui la ménera à la vérité se trouvait dans la boîte mail de Bob. Alice arriva à trouver
    un bout de papier avec écrit dessus : "Mon mot de passe est l'empreinte de ceciestmonmotdepasse". Aidez Alice à trouver l'empreinte du mot de passe! \\

    Pour cela, vous devez compléter deux fonctions :
    \begin{enumerate}
        \item \lstinline{is_a_prime_number(num)} qui vérifie que \lstinline{num} est un nombre premier ou pas. Un nombre premier est un entier naturel 
        qui admet exactement deux diviseurs distincts entiers et positifs. Ces deux diviseurs sont 1 et le nombre considéré, 
        puisque tout nombre a pour diviseurs 1 et lui-même, les nombres premiers étant ceux qui n’en possèdent aucun autre.
        
        \item \lstinline{fingerprinting(p, message)} qui implémente l'algorithme de fingerprinting suivant :
              \begin{enumerate}
                  \item Si \lstinline{p} est un nombre premier, calculez la valeur de hachage de la chaîne à l'aide de la fonction \lstinline{hash(...)}, puis calculez le modulo du résultat du hachage.
                  \item Sinon, imprimez un message qui dit que le nombre n'est pas un nombre premier.    
              \end{enumerate}
    \end{enumerate}

    Si vous réussisez à implémenter les deux fonctions correctement, le code vous imprimera : \lstinline{Connection réussie? True}.

    À vos ordis, détectives!

    \lstinputlisting[language = python]{fingerprinting.py}

    \begin{solution}
        \lstinputlisting[language = python]{fingerprinting_solution.py}
    \end{solution}

    
\end{Exercice}


\end{document}