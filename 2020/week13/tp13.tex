\input{../header.tex}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Programmation orientée objet: Héritage et Polymorphisme}
% TODO: Objectifs à atteindre (Alpha)
% TODO (All): Utiliser \lstinline{} sur tous les mots-clés, noms de classes, d'attributs, méthodes,...

Le code présenté dans les énoncés se trouve sur Moodle, dans le dossier \lstinline{Ressources}.
\section{Rappel: Surcharge des opérateurs - Python}
% Python
% TODO: Alpha 
% Utiliser une classe Fraction et effectuer des opérations de base sur des Fractions.
Dans cette section, vous manipulerez des fractions sous forme d'objets. Vous ferez des opérations de base sur ce nouveau type d'objets.

\begin{Exercice}[5 minutes]
    Dans un projet que vous aurez au préalable préparé, créez un fichier appelé \lstinline{surcharge.py}.% TODO: Nom fichier à définir.
    À l'intérieur de ce fichier, créer une classe \lstinline{Fraction} qui aura comme attributs un numérateur et un dénominateur. 
\end{Exercice}

\begin{Exercice}[5 minutes]
Définir un constructeur à votre classe. Assignez des valeurs par défaut à vos attributs.

    \begin{conseil}
        Les valeurs par défaut seront assignées à votre objet au cas où il est instancié sans valeurs. Ainsi en faisant \lstinline{f = Fraction()}, on obtiendra un objet \lstinline{Fraction} ayant pour valeurs un numérateur et un dénominateur à 1 soit $\frac{1}{1}$.
    \end{conseil}
\end{Exercice}

\begin{Exercice}[5 minutes]

\end{Exercice}


\section{Notions d'héritage - Java}
% TODO: Remplacer "sous-classe" par classe fille.
% TODO: Remplacer dessinateur par illustrateur.
% TODO: Utiliser \lstinline{} sur tous les mots-clés dont les noms d'attributs, classes, méthodes,...
% TODO: Au lieu de définir une méthode printInfo(), ne serait-ce pas plus judicieux de rédéfinir la méthode toString()?

Le but de cette partie est de pratiquer et d'assimiler les notions liées à l'héritage. Pour cela. nous allons nous inspirer de l'exemple présenté dans le cours. 

Nous allons créer une classe \lstinline{Livre()} qui contiendra deux sous-classes, \lstinline{Livre_Audio()} et \lstinline{Livre_Illustre()}. Les sous-classes hériteront des attributs et méthodes de la classe mère. 

\begin{Exercice}[10 minutes] Création de classe et sous-classes\\

Créez la classe mère \lstinline{Livre()} avec les caractéristiques suivantes:
\begin{itemize}
	\item une variable privée \lstinline{titre}
	\item une variable privée \lstinline{auteur}
	\item une variable privée \lstinline{annee}
	\item une variable privée \lstinline{note} (initialisée à \lstinline{-1})
	\item le constructeur public prenant en argument les trois premières variables ci-dessus
	\item une méthode \lstinline{printInfo()} qui affiche le titre, l'auteur, l'année et la note d'un ouvrage
	\item une méthode \lstinline{setNote()} qui permet de définir la variable \lstinline{note}
\end{itemize}

Créez les classes filles avec les caractéristiques suivantes:\\
\lstinline{class Livre_Audio extends Livre}
\begin{itemize}
	\item un attribut \lstinline{narrateur}

\end{itemize}
\lstinline{class Livre_Illustre extends Livre}
\begin{itemize}
	\item un attribut \lstinline{dessinateur}

\end{itemize}

\lstinputlisting{Ressources/heritage.java}

\begin{conseil}
En java, lors de la déclaration d'une classe, le mot clef \lstinline{extends} permet d'indiquer qu'il s'agit d'une sous-classe de la classe indiquée. 

Le mot clef \lstinline{super} permet à la sous classe d'hérité d'éléments de la classe mère. \lstinline{super} peut être utilisé dans le constructeur de la sous-classe selon l'example suivant: \lstinline{super(variable_mère_1, variable_mère_2, variable_mère_3, etc.);}. Ainsi, il n'est pas nécessaire de redefinir toutes les variables d'une sous-classe !

L'instruction \lstinline{super} doit toujours être la première instruction dans le constructeur d'une sous-classe. 
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/heritage-solution-1.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[5 minutes] Méthode et héritage \\

Maintenant que vous avez créé la classe et les sous classes correspondantes, vous pouvez créer un objet \lstinline{Livre} à l'aide du constructeur de la sous-classe \lstinline{Livre_Audio}. 
% TODO: Phrase à reformuler. S'agit-il de valeurs par défaut du constructeur ou des valeurs de l'instance?
Si vous manquez d'inspiration vous pouvez indiquer les valeurs suivantes : titre: "Hamlet", auteur: "Shakespeare", année: "1609" et le narrateur "William.\\

Une fois l'objet créé, attribuez lui une note à l'aide de la méthode définie précédemment.\\ 

Finalement, utilisez la méthode \lstinline{printInfo()} pour afficher les informations du livre.\\

La méthode étant définie dans la classe mère, elle n'a pas connaissance de la variable \lstinline{narrateur} définie dans la sous-classe. Redéfinissez la méthode dans la sous-classe pour y inclure l'information sur le narrateur. \\

\begin{conseil}
\textbf{Attention}, on vous demande de créer un objet \lstinline{Livre} et non pas \lstinline{Livre_Audio}.

Le mot clef \lstinline{super} peut être utilisé dans la redéfinition d'une méthode selon l'example suivant: \lstinline{super.nom_de_la_methode();}. Cette instruction permet  d'inclure tout ce qui est défini dans la ``méthode mère'' et vous pouvez la complétez selon les caractéristiques de votre sous-classe.

%TODO: Phrase à reformuler. super représente l'objet parent. Il faudra faire le parallèle entre super et this (qui représente l'instance en cours).
L'instruction \lstinline{super} doit toujours être la première instruction dans le redéfinition d'une méthode dans une sous-classe. 
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/heritage-solution-2.java}
	\lstinputlisting{Solutions/heritage-solution-3.java}
\end{solution}

\end{Exercice}


\section{Polymorphisme - Java}
% Java
% TODO: Reprendre les noms de classe des exercices de cette semaine. Par exemple, on avait finalement utilisé le mot Fighter au détriment de Combattant.
% TODO: Utiliser \lstinline{} sur tous les mots-clés dont les noms d'attributs, classes, méthodes,... Par exemple sur Soigneur-

Dans cette partie de cette session d'exercice, vous serez amenés à créer 2 nouvelles sous-classes de la classe mère combattant. La première classe représentera un soigneur, qui, lorsqu'il attaquera quelqu'un, le soignera au lieu de le blesser. La deuxième classe représentera un combattant spécialisé dans l'attaque, qui aura la capacité d'attaquer un certain nombre de fois (ce nombre sera défini au moment ou vous l'instancierez). Pensez à télécharger la dernière version de la classe Combattant dans le dossier ressources.\\

Voici le squelette du code que vous trouverez également dans le dossier ressources du moodle : \\

\lstinputlisting{ressources/Combattant_squelette.java}

\begin{Exercice}[5 minutes] Sous-classe Soigneur \\

Commencez par déclarer une nouvelle sous-classe soigneur. Cette sous-classe prendra un nouvel attribut privé, entier, nommé résurrection, qui vaudra 1 lors de l'instanciation. \\

Déclarez le constructeur de cette classe ainsi que les getter et setter permettant d'interagir avec ce nouvel attribut. \\

\begin{conseil}
Pensez à utiliser le constructeur de votre classe mère Combattant
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/Soigneur.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[10 minutes] Méthode résurection de la sous-classe Soigneur \\

Commencez par déclarer une nouvelle méthode nommée résurrection(Fighter other). \\

Cette méthode permettra de faire revenir un Combattant à la vie, mais le Soigneur ne pourra le faire qu'une seule fois. \\

Commencez par controler que l'instance depuis laquelle la méthode est appelée soit toujours en vie. Si ce n'est pas le cas, indiquez le en indiquant : nom\_instance est mort et ne peut plus rien faire.  \\ 

Contrôlez ensuite que l'instance other soit vraiment morte. Si ce n'est pas le cas, indiquez le via : nom\_other est toujours en vie. \\

Pour finir, contrôlez que l'attribut résurrection de l'instance depuis laquelle la méthode est appelée soit égale à 1. Si ce n'est pas le cas, indiquez : nom\_instance ne peut plus ressuciter personne.\\

Si tous ces éléments sont réunis, faites revenir le Combattant other à la vie en lui remettant 10 points de vie et en l'ajoutant à la liste des instances de la classe Combattant. Pensez également à mettre l'attribut résurrection de l'instance appelée à   
0 afin de l'empêcher de réutiliser ce pouvoir, à appeler la méthode checkHealth(), et à indiquer : nom\_other est revenu à la vie ! \\

\begin{conseil}
Utilisez un branchement conditionnel pour les contrôles. \\

Une nouvelle méthode nommée addInstances(Combattant other) a été créée dans la classe Combattant. Regardez à quoi elle sert et utilisez la. \\
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/resurrection.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[10 minutes] Méthode attack de la sous-classe soigneur \\

Réécrivez la méthode attack de la sous-classe soigneur afin d'ajouter des points de vie à other au lieu de lui en retirer. \\

Le seul argument nécessaire pour cette méthode sera le Combattant other. \\

Commencez par contrôler que le Soigneur depuis lequel la méthode est appelée est encore en vie. Si ce n'est pas le cas, indiquez : nom\_instance est mort et ne peut plus rien faire.

Contrôlez ensuite si other est toujours en vie. Si ce n'est pas le cas indiquez : nom\_other est déjà mort, ressuscitez le afin de pouvoir le soigner. Contrôlez également qu'il ait moins de 10 points de vie. Si ce n'est pas le cas, indiquez le via : nom\_other a déjà le maximum de points de vie. \\

Si toutes ces conditions sont réunies, ajoutez la valeur de l'attaque de l'instance qui appelle la méthode aux points de vie de other. Pour terminer, appelez la méthode de classe checkHealth().

\begin{conseil}
% Ce conseil devrait être plus étoffé 
Pensez à utiliser du branchement conditionnel pour les contrôles. \\
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/Soigneur_attack.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[5 minutes] Sous-classe Attaquant \\

Commencez par déclarer une nouvelle sous-classe Attaquant. Cette sous-classe prendra un nouvel attribut privé, entier, nommé multiplicateur, qui sera passé en argument du constructeur de la sous-classe. \\

Déclarez le constructeur de cette classe ainsi que les getter et setter permettant d'interagir avec ce nouvel attribut. \\

\begin{conseil}
Pensez à utiliser le constructeur de votre classe mère Combattant
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/Attaquant.java}
\end{solution}

\end{Exercice}

\begin{Exercice}[10 minutes] Méthode attack de la sous-classe Attaquant \\

Réécrivez la méthode attack de la sous-classe Attaquant afin d'effectuer plusieurs attaques sur other en fonction de son attribut multiplicateur. \\

Y'a t-il besoin de contrôler si l'instance depuis laquelle la méthode est appelée est encore en vie ? \\

Indiquez systématiquement le numéro de l'attaque, puis effectuez l'attaque. Répétez le procédé jusqu'à ce que le numéro de l'attaque soit égal à celui de multiplicateur\_instance.

\begin{conseil}
Aidez vous de la méthode attack de la classe mère Combattant. \\
\end{conseil}

\begin{solution}
	\lstinputlisting{Solutions/Attaquant_attack.java}
\end{solution}

\end{Exercice}

Si tout est correct, en utilisant ce main : \\

\lstinputlisting{ressources/Combattant_main.java} 

Vous devriez obtenir : \\

\lstinputlisting{Solutions/Combattant_main_solution.java} 

\section{Héritage en Python}
% Python
% TODO: Définir des objectifs. Rappel de la syntaxe.
% Proposer des exercices sur l'héritage. Un exemple pourrait être de définir une classe mère Figure et des classes filles Cercle, Rectangle... La classe mère aura comme méthodes get_aire() et get_perimètre()
% Hien

\end{document}
