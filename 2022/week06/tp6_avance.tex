\input{../header.tex}


\begin{document}

% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Complexité, Programmation orientée objet et Polymorphisme - exercices avancés}

Le but de cette série d'exercices est d'aborder les notions présentées durant la séance de cours. Cette série d'exercices sera orientée autour des points suivants:
\begin{enumerate}
    \item la complexité des algorithmes
    \item la programmation orientée objet
    \item le polymorphisme
\end{enumerate}

Les languages de programmation qui seront utilisés pour cette série d'exercices sont Java et Python.

Le temps indiqué (\faClock) est à titre indicatif.


\section{Complexité (10 minutes)}

Pour chacun des programmes ci-dessous, donnés à chaque fois en Python et Java, indiquez en une phrase, ce que font ces algorithmes et calculez leur complexité temporelle avec la notation $O( )$. Le code est écrit en Python et en Java. \\


\begin{Exercice}[10 minutes] \textbf{Complexité} \\
    Quelle est la complexité du programme ci-dessous?\\
        \textbf{Python :}
        \begin{lstlisting}[language=Python]
        # Entrée: n un nombre entier
        def algo5(n):
            m = 0
            for i in range(n):
                for j in range(i):
                    m += i+j
            return m
        \end{lstlisting}
        
        \textbf{Java :}
        \begin{lstlisting}[language=Java]
            public static int algo5(int n) {
                int m = 0;
                for (int i=0; i < n; i++){
                    for (int j=0; j < i; j++){
                        m += i+j;
                    }
                }
                return m;
            }
        \end{lstlisting}
    
        \begin{enumerate}
            \item $O(n^2)$
            \item $O(n)$
            \item $O(\log(n))$
            \item $O(2^n)$
        \end{enumerate}

    \begin{solution} 
    L'algorithme est composé de 2 boucles \textbf{imbriquées} suivant une suite définie par $\frac{n(n-1)}{2}$. L'algorithme va additionner les index $i$ et $j$ à chaque itération et les rajouter à $m$.
    Cela veut dire que nous parcourons la liste un maximum de $n \times n$ fois, $n$ étant la taille de la liste. La complexité de l'algorithme est ainsi de $O(n^2)$.
    \end{solution}
    
\end{Exercice}
    
\newpage
\section{Interaction entre plusieurs instances d'une même classe (30 minutes)}

Dans cette section, nous allons simuler un jeu de combat entre deux protagonistes représentant des instances d'une classe \lstinline{Fighter} que nous allons créer.
Chaque \lstinline{Fighter} aura des attributs qui le définissent. Ces attributs sont:

\begin{itemize}
    \item \lstinline{nom:}\textit{(String)} chaque combattant sera identifié par un nom unique.
    \item \lstinline{health:}\textit{(int)} représentant le nombre de points de vie d'un combattant. Il contient des valeurs comprises entre 0 et 10. À l'instanciation de l'objet, le combattant a 10 points de vie par défaut-
    \item \lstinline{attaque:}\textit{(int)} représentant une valeur qui sera utilisée pour calculer le nombre de points de dégâts infligés à l'adversaire.
    \item \lstinline{défense:}\textit{(int)} représentant une valeur qui sera utilisée pour calculer le nombre de points de dégâts reçus.\\
\end{itemize}

Deux attributs de classe seront également utilisés :
\begin{itemize}
\item \lstinline{instances :} Liste comprenant les combattants qui ont été instanciés et qui sont toujours en vie.
\item \lstinline{attackModifier :} Dictionnaire comportant 3 types d'attaques, chacune modifiant les dégâts qui vont être infligés. Les trois types d'attaques sont \lstinline{poing, pied et tête} modifiant respectivement l'attaque par 1, 2, 3.\\
\end{itemize}
Le but de cette partie est d'étudier les interactions entre deux instances d'une même classe. Cette classe se présentera sous la forme d'un \lstinline{Fighter}. Chaque instance de la classe \lstinline{Fighter} pourra attaquer les autres instances.
\\
Vous devrez compléter les 4 méthodes suivantes :
\begin{enumerate}
\item \lstinline{isAlive()}
\item \lstinline{checkDead()}
\item \lstinline{checkHealth()}
\item \lstinline{attack(String type, Fighter other)}\\
\end{enumerate}

Voici le squelette du code (à télécharger sur Moodle) :
\lstinputlisting{ressources/Fighter.java}
\begin{Exercice}[5 minutes] isAlive()\\
    Définir une méthode \lstinline{isAlive()} de type \lstinline{boolean} qui retournera \lstinline{true} si l'instance a plus que 0 points de vie et \lstinline{false} si l'instance en a moins.
\begin{solution}
	\lstinputlisting{solutions/isalive.java}
\end{solution}
\end{Exercice}
\begin{Exercice}[10 minutes] checkDead()\\
    Définir une méthode \lstinline{checkDead()} qui parcourt la liste des instances, et contrôle que chacune d'entre elle est encore en vie. Si ce n'est pas le cas, l'instance en question est supprimée de la liste des instances et le message ``\lstinline{nomInstance} est mort'' sera affiché.
    
\begin{conseil}
Prenez le problème dans l'autre sens, créez une liste temporaire. Si l'instance est vivante, ajoutez la à cette nouvelle liste. Pour finir, mettez à jour votre liste d'instances à l'aide de votre liste temporaire.\\
L'attribut \lstinline{instances} étant une liste, vous pouvez parcourir cette liste d'instances en utilisant une boucle \lstinline{for}. 
\end{conseil}
\begin{solution}
	\lstinputlisting{solutions/checkdead.java}
\end{solution}
\end{Exercice}
\begin{Exercice}[5 minutes] checkHealth()\\
    Définir une méthode \lstinline{checkHealth()} qui parcourt la liste des instances et affiche le nombre de points de vie qui reste au combattant sous le format ``\lstinline{nomInstance} a encore \lstinline{healthInstance} points de vie". 
\begin{solution}
	\lstinputlisting{solutions/checkhealth.java}
\end{solution}
\end{Exercice}
\begin{Exercice}[10 minutes] attack(String type Fighter other)\\
    Définir une méthode \lstinline{attack(String type, Fighter other)} qui permettra de retirer des points de vie au combattant \lstinline{other} en fonction de l'attaque de l'instance appelée, du type d'attaque sélectionné et de la défense de \lstinline{other}. \\
    
    Commencez par contrôler si \lstinline{other} est encore en vie.Si tel n'est pas le cas, indiquez qu'il est déjà mort : ``\lstinline{other_name} est déjà mort". \\
     Si \lstinline{other} est encore en vie, retirez des points de vie à \lstinline{other}. Le nombre de points de vie devant être retiré se calcule en utilisant la formule suivante : \lstinline{attack_modifier(type)} * \lstinline{attack_instance} - \lstinline{defense_other}. Appelez ensuite les fonctions \lstinline{checkDead()} et \lstinline{checkHealth()} afin d'avoir un aperçu des combattants restants et de leur santé.
    
\begin{solution}
	\lstinputlisting{solutions/attack.java}
\end{solution}
\end{Exercice}
Pour terminer, vous pouvez exécuter le code ci-dessous (disponible dans le dossier Code sur Moodle) pour vérifier que votre programme fonctionne correctement : \\
\lstinputlisting{ressources/main2.java}
Vous devriez obtenir ce résultat : \\
\lstinputlisting{ressources/main2solution.java}


\section{Héritage en Python }
\begin{Exercice}[15 minutes]\textbf{Classe Point (Suite)}

Lors de la séance précédente, vous avez défini une classe \lstinline{Point} représentant un point de 2~dimensions, avec des coordonnées \lstinline{x} et \lstinline{y}, ainsi que des opérations basiques sur des points 2D. Pour cet exercice, vous allez implémenter une classe de points à 3 dimensions qui héritera de la classe \lstinline{Point} créée précédemment. 
%À travers cet exercice, nous voudrions également vous présenter une syntaxe en Python qui concerne l'utilisation des 'décorateurs'.\\


Voici la classe \lstinline{Point} qui a été légèrement modifiée (Vous trouverez le fichier sur Moodle, dans le dossier~\lstinline{Code}):
\lstinputlisting{ressources/Point.py} 

Écrivez une classe qui hérite de \lstinline{Point}. Nommez la \lstinline{Point3D}. Après avoir rajouté la 3ème dimension comme attribut, effectuez les opérations ci-dessous:

\begin{itemize}
	\item Rajoutez une méthode qui renvoie une représentation vectorielle du point. Vous pouvez utiliser une liste.
	\item Recalculez la distance euclidienne et le milieu pour le point 3D.
	\item \advanced Si vous voulez vous familiariser encore plus avec les méthodes de classe en Python, implémentez deux autres algorithmes de calculs de distance: les distances de \href{https://fr.wikipedia.org/wiki/Distance_de_Manhattan}{\textcolor{cyan}{Manhattan}} et \href{https://en.wikipedia.org/wiki/Minkowski_distance}{\textcolor{cyan}{Minkowski}}.
\end{itemize}
\lstinputlisting{ressources/Point3D.py} 

\begin{conseil}
%Recherchez sur Internet des documentations sur les décorateurs Python, notamment sur 'property', 'setter' et 'getter'. 

Que fait \lstinline{super().__init__()}?\\
Dans un espace à 3 dimensions, la formule pour calculer la distance entre un $p_1 = (x_1, y_1, z_1)$ et $p_2 = (x_2, y_2, z_2)$ est $\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 + (y_1 - y_2)^2}$.
\end{conseil}
\begin{solution}
\lstinputlisting{solutions/Point3D.py} 
\end{solution}
\end{Exercice} 

\begin{Exercice}[15 minutes]\textbf{Un exemple appliqué}

Dans les établissements universitaires, on rencontre souvent des problèmes lors du calcul de salaires du personnel. Sans penser aux recherches effectuées par certains professeurs, on va essayer de calculer les salaires de ceux qui sont reconnus comme `Professeur' (ordinaire, titulaire, associé ou assistant) à l'université et ceux qui y donnent des cours à temps partiel (on va les considérer comme `Collaborateurs' dans cet exercice).

La classe mère dans ce cas est nommée \lstinline{Enseignant}, qui possède une propriété - le salaire annuel moyen. On voudrait que la méthode qui calcule cette quantité renvoie 60 000 (dollars américains) si l'enseignant a moins de 10 ans d'expérience, et 100 000 sinon. Si l'enseignant travaille à temps partiel, la méthode devrait renvoyer une chaîne qui dit `Le salaire annuel ne s'applique pas aux collaborateurs'.

Ensuite, on veut calculer la paye mensuelle pour chaque type d'employé. Pour les \lstinline{Professeurs}, la paye devrait être calculée sur la base de deux sources de revenu: un salaire mensuel et une commission pour chaque comité où ils participent. 

D'autre part, pour les \lstinline{Collaborateurs}, la paye est calculée sur une base horaire i.e \textit{taux horaire $\times$ nombres d'heures de travail (par mois)}.


Complétez le code ci-dessous:

\lstinputlisting{ressources/Enseignant.py} 

\begin{conseil}
Pensez à redéfinir les attributs de la classe mère en utilisant \lstinline{super().__init__()}.
\end{conseil}

\begin{solution}
\lstinputlisting{solutions/Enseignant.py} 
\end{solution}
\end{Exercice}

\end{document}
