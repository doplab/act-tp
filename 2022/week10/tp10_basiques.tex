\input{../header.tex}


\begin{document}

% Change the following values to true to show the solutions or/and the hints
\ShowSolutiontrue
\ShowConseiltrue
\titre
\cours{Algorithmes de tri et Complexité - exercices basiques}

Le but de cette série d'exercices est d'aborder les notions présentées durant la séance de cours. Cette série d'exercices sera orientée autour des points suivants:
\begin{enumerate}
    \item la récursivité,
    \item la complexité des algorithmes et
    \item les algorithmes de tri
\end{enumerate}

Les langages de programmation qui seront utilisés pour cette série d'exercices sont Java et Python.

Le temps indiqué (\faClock) est à titre indicatif.

\section{Récursivité (10 minutes)}

Le but principal de la récursivité est de résoudre un gros problème en le divisant en plusieurs petites parties à résoudre.

\begin{Exercice}[10 minutes] \textbf{Somme des chiffres} \\
    Écrivez un algorithme récursif en Python ou en Java qui prend un nombre et retourne la somme des chiffres dont il est composé. Par exemple, la somme des chiffres de 126 est : 1+2+6 = 9.
    
    \begin{conseil}
    
    Pour obtenir les chiffres qui composent un nombre, utilisez l'opérateur \lstinline{\%} (modulo - \url{https://fr.wikipedia.org/wiki/Modulo\_(op\%C3\%A9ration)}). \\
    Pour obtenir le nombre 12 à partir du nombre 126, il vous suffit de faire la division entière par 10. En Python, on utilise l'opérateur \lstinline{\/\/} : 126 \lstinline{\/\/} 10 = 12. En Java, la division entre deux variables de type \lstinline{int} est entière, et vous n'aurez ainsi qu'à utiliser l'opérateur de division normal \lstinline{\/} : 126 \lstinline{\/} 10 = 12.
    
    \end{conseil}
    
    \begin{solution}
    \textbf{Python :}
        \lstinputlisting{solutions/question6.py}
                
    \textbf{Java :}
       \lstinputlisting{solutions/question6.java}
    
    \end{solution}
\end{Exercice}
\newpage

\section{Complexité (40 minutes)}

Indiquez en une phrase, ce que font ces algorithmes ci-dessous et calculez leur complexité temporelle avec la notation $O( )$. Le code est écrit en Python et en Java. \\

\begin{Exercice}[10 minutes] \textbf{Complexité} \\

    Quelle est la complexité du programme ci-dessous?\\
    \textbf{Python :}
    \begin{lstlisting}{language=Python}
    # Entrée: n un nombre entier
    def algo1(n):
        s = 0
        for i in range(10*n):
            s += i
        return s
    \end{lstlisting}
    
    \textbf{Java :}
    \begin{lstlisting}{language=Java}
        public static int algo1(int n) {
            int s = 0;
            for (int i=0; i < 10*n; i++){
                s += i;
            }
            return s;
        }  \end{lstlisting}

    \begin{enumerate}
        \item $O(n)$
        \item $O(n^3)$
        \item $O(\log(n))$
        \item $O(n^n)$
    \end{enumerate}
    
    \begin{conseil}
    Rappelez vous que la notation $O()$ sert à exprimer la complexité d'algorithmes dans le \textbf{pire des cas}. Les règles suivantes vous seront utiles. Pour $n$ étant la taille de vos données, on a que :
    \begin{enumerate}
        \item Les constantes sont ignorées : $O(2n) = 2*O(n) = O(n)$ 
        \item Les termes dominés sont ignorés : $O(2n^2+5n+50)$ = $O(n^2)$
    \end{enumerate}
    \end{conseil}

    \begin{solution}
        L'algorithme est composé d'une boucle qui incrémente une variable \lstinline{s}. Il effectue $10*n$ l'opération et par conséquent a une complexité de $O(n)$.
    \end{solution}
\end{Exercice}
\newpage
\begin{Exercice}[10 minutes] \textbf{Complexité} \\
    Quelle est la complexité du programme ci-dessous?\\
    \textbf{Python :}
    \begin{lstlisting}[language=Python]
        # Entrée: L est une liste de nombres entiers et M un nombre entier
        def algo2(L, M):
            i = 0
            while i < len(L) and L[i] <= M:
                i += 1
            s = i - 1
            return s
    \end{lstlisting}
    
    \textbf{Java :}
    \begin{lstlisting}[language=Java]
        public static int algo2(int[] L, int M) {
            int i = 0;
            while (i < L.length && L[i] <= M){
                i += 1;
            }
            int s = i - 1;
            return s;
        }
    \end{lstlisting}

    \begin{enumerate}
        \item $O(n^3)$
        \item $O(\log(n))$
        \item $O(n)$
        \item $O(n^n)$
    \end{enumerate}

    \begin{solution}
    L'algorithme est composé d'une boucle \lstinline{while} qui va parcourir une liste \lstinline{L} jusqu'à trouver une valeur qui est supérieure à \lstinline{M}. Ainsi, dans le pire des cas, l'algorithme parcourt toute la liste, et a donc une complexité de $O(n)$, $n$ étant la taille de la liste.
    \end{solution}
\end{Exercice}
\begin{Exercice}[10 minutes] \textbf{Complexité} \\
    Quelle est la complexité du programme ci-dessous?\\
        \textbf{Python :}
        \begin{lstlisting}[language=Python]
        #Entrée: L et M sont 2 listes de nombres entiers
        def algo(L, M):
            n = len(L)
            m = len(M)
            for i in range(n):
                L[i] = L[i]*2
            for j in range(m):
                M[j] = M[j]%2
        \end{lstlisting}
        
        \textbf{Java :}
        \begin{lstlisting}[language=Java]
            public static void algo(int[] L, int[] M) {
                int n = L.length;
                int m = M.length;
                for (int i=0; i < n; i++){
                    L[i] = L[i]*2;
                }
                for (int j=0; j < m; j++){
                    M[j] = M[j]%2;
                }
            }
        \end{lstlisting}

        \begin{enumerate}
            \item $O(n^2)$
            \item $O(n + m)$
            \item $O(n)$
            \item $O(2^n)$
        \end{enumerate}

        \begin{solution}
        L'algorithme est composé de 2 boucles. La première parcourt une liste \lstinline{L} et multiplie par 2 les éléments de la liste. 
        L'autre parcourt une liste \lstinline{M} et assigne à chaque élément le reste de la division euclidienne de l'élément par 2. 
        Soient $n$ et $m$ les tailles respectives de \lstinline{L} et de \lstinline{M}, on obtient une complexité de $O(n + m)$. 
        Ainsi, l'élément ayant la plus grande complexité sera utilisé pour déterminer la complexité de l'algorithme dans son ensemble.
        \end{solution}
\end{Exercice}

\begin{Exercice}[10 minutes] \textbf{Complexité} \\
    Quelle est la complexité du programme ci-dessous?\\
    \textbf{Python :}
    \begin{lstlisting}[language=Python]
    #Entrée: L est une liste de nombre entiers
    def algo(L):
        n = len(L)
        i = 0
        s = 0
        while i < math.log(n):
            s += L[i]
            i += 1
        return s
    \end{lstlisting}
    
    \textbf{Java :}
    \begin{lstlisting}[language=Java]
        import java.lang.Math; 

        public static void algo(int[] L) {
            int n = L.length;
            int s = 0;
            for (int i=0; i < Math.log(n); i++){
                s += L[i];
            }
        } \end{lstlisting}

    \begin{enumerate}
        \item $O(n^2)$
        \item $O(n)$
        \item $O(\log(n))$
        \item $O(n^n)$
    \end{enumerate}

    \begin{solution}
    L'algorithme est composé d'une boucle qui va itérer sur $\log(n)$ éléments et 
    va calculer la somme de ces éléments. Ainsi, l'algorithme a une complexité de $O(\log n)$.
    Le temps d'exécution de ce programme peut être visualisé sur la courbe jaune du graphe ci-dessous (\ref{bigO}).
    \end{solution}
    
    \begin{figure}[h!]
        \centering
        \includegraphics[width=10cm]{ressources/complexity.png}
        \caption{Représentation de complexités temporelles}
        \label{bigO}
    \end{figure}

    

\end{Exercice}

\newpage

\begin{Exercice}[10 minutes] \textbf{Complexité \optionnel} \\
    Quelle est la complexité du programme ci-dessous?\\
        \textbf{Python :}
        \begin{lstlisting}[language=Python]
        # Entrée: n un nombre entier
        def algo(n):
            m = 0
            for i in range(n):
                for j in range(i):
                    m += i+j
            return m
        \end{lstlisting}
        
        \textbf{Java :}
        \begin{lstlisting}[language=Java]
            public static int algo(int n) {
                int m = 0;
                for (int i=0; i < n; i++){
                    for (int j=0; j < i; j++){
                        m += i+j;
                    }
                }
                return m;
            }
        \end{lstlisting}
    
        \begin{enumerate}
            \item $O(n^2)$
            \item $O(n)$
            \item $O(\log(n))$
            \item $O(2^n)$
        \end{enumerate}

    \begin{solution} 
    L'algorithme est composé de 2 boucles \textbf{imbriquées} suivant une suite définie par $\frac{n(n-1)}{2}$. L'algorithme va additionner les index $i$ et $j$ à chaque itération et les rajouter à $m$.
    Cela veut dire que nous parcourons la liste un maximum de $n \times n$ fois, $n$ étant la taille de la liste. La complexité de l'algorithme est ainsi de $O(n^2)$.
    \end{solution}
    
\end{Exercice}

\section{Algorithmes de Tri (60 minutes)}

\begin{Exercice}[10 minutes] \textbf{Tri par insertion (Python)}\\
    Soit un nombre entier \lstinline{n}, et une liste triée \lstinline{l}. Ecrivez un programme Python qui insère la valeur \lstinline{n} dans la liste \lstinline{l} tout en s'assurant que la liste \lstinline{l} reste triée.

    \lstinputlisting{ressources/question9.py}

    \begin{Example}{\faTerminal \quad Exemple}
        En passant les arguments suivants à votre programme: n=5 et l=[2,4,6]. Ce dernier devra retourner \lstinline{l =[2,4,5,6]}
    \end{Example}

    \begin{solution}
        \lstinputlisting{solutions/question9.py}
    \end{solution}


\end{Exercice}

\begin{Exercice} [30 minutes] \textbf{Tri fusion (Merge Sort) - Python} \\
    À partir de deux listes triées, on peut facilement construire une liste triée comportant les éléments issus de ces deux listes (leur \textit{fusion}). Le principe de l'algorithme de tri fusion repose sur cette observation : le plus petit élément de la liste à construire est soit le plus petit élément de la première liste, soit le plus petit élément de la deuxième liste. Ainsi, on peut construire la liste élément par élément en retirant tantôt le premier élément de la première liste, tantôt le premier élément de la deuxième liste (en fait, le plus petit des deux, à supposer qu'aucune des deux listes ne soit vide, sinon la réponse est immédiate). 
    
    Les étapes à suivre pour implémenter l'algorithme sont les suivantes:
    \begin{enumerate}
        \item Si le tableau n'a qu'un élément, il est déjà trié.
        \item Sinon, séparer le tableau en deux parties plus ou moins égales.
        \item Trier récursivement les deux parties avec l'algorithme de tri fusion.
        \item Fusionner les deux tableaux triés en un seul tableau trié.
    \end{enumerate}
    
    Soit la liste \lstinline{l} suivante [38, 27, 43, 3, 9, 82, 10], triez les éléments de la liste en utilisant un tri fusion. Combien d'itération effectuez-vous?
    
    \begin{itemize}
        \item \textbf{Python :}
            \lstinputlisting{ressources/merge_sort.py}
    \end{itemize}
    
    \begin{conseil}
    \begin{itemize}
        \item L'algorithme est récursif. 
        \item Revenez à la visualisation de l'algorithme dans les diapositives 80 à 108 pour comprendre comment marche concrètement le tri fusion. 
    \end{itemize}
    
    \end{conseil}
    
    \begin{solution}
        \textbf{Python :}
         \lstinputlisting{solutions/merge_sort.py}
    \end{solution}
   
    \begin{solution}
        Le tri fusion est un algorithme récursif. Ainsi, nous pouvons exprimer sa complexité temporelle via une relation de récurrence : $T(n) = 2T(n/2) + O(n)$. En effet, l'algorithme comporte 3 étapes :
        \begin{enumerate}
            \item ``Divide Step'', qui divise les listes en deux sous-listes, et cela prend un temps constant
            \item ``Conquer Step'', qui trie récursivement les sous-listes de taille $n/2$ chacune, et cette étape est représentée par le terme $2T(n/2)$ dans l'équation.
            \item La dernière étape consiste à fusionner les listes, sa complexité est de $O(n)$.
        \end{enumerate}
        La solution à cette équation est $O(n \log n)$.
    \end{solution}
\end{Exercice}


\begin{Exercice} [20 minutes] \textbf{Tri à bulles (Bubble Sort) - Python} \\
    Le tri à bulles consiste à parcourir une liste et à comparer ses éléments. Le tri est effectué en permutant les éléments de telle sorte que les éléments les plus grands soient placés à la fin de la liste. 
    
    Concrètement, si un premier nombre $x$ est plus grand qu'un deuxième nombre $y$ et que l'on souhaite trier l'ensemble par ordre croissant, alors $x$ et $y$ sont mal placés et il faut les inverser. Si, au contraire, $x$ est plus petit que $y$, alors on ne fait rien et l'on compare $y$ à $z$, l'élément suivant.
    
    Soit la liste \lstinline{l = [1, 2, 4, 3, 1]}, triez les éléments de la liste en utilisant un tri à bulles. Combien d'itérations effectuez-vous?
    
    \begin{itemize}
            \item \textbf{Python :}
                \lstinputlisting{ressources/question8.py} 
        \end{itemize}
       
        \ \\
        
        \begin{solution}
        \textbf{Python :}
        \lstinputlisting{solutions/question8.py}
    
        L'algorithme a une complexité de $O(n^2)$ car il contient deux boucles qui parcourent la liste.\\\\\\
                
    \end{solution}
    \end{Exercice}





\end{document}
