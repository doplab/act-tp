\input{../header.tex}
\usepackage{array}
\usepackage{blindtext}
\usepackage{multicol}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}
% Change the following values to true to show the solutions or/and the hints
\ShowSolutionfalse
\ShowConseiltrue
\ShowNotefalse
\titre
\cours{Classes abstraites et interfaces}

% Le but de cette séance est d'approfondir les notions de programmation orientée objet vues précédemment. 

Les exercices sont construits autour des concepts d'héritage, de classes abstraites et d'interfaces. Au terme de cette séance, vous devez être en mesure de différencier une classe abstraite d'une interface, savoir à quel moment utiliser l'un ou l'autre, utiliser le concept d'héritage multiple, factoriser votre code afin de le rendre mieux structuré et plus lisible.

Cette feuille d'exercices est divisée en 2 sections. L'une portant sur les classes abstraites et l'autre sur les interfaces. 

Une autre feuille comportant des exercices de consolidation sur les notions abordées précédemment est disponible sur Moodle.

Les exercices de cette feuille d'exercices doivent être faits uniquement en \lstinline{Java}.

Le code présenté dans les énoncés se trouve sur Moodle, dans le dossier \lstinline{Ressources}.

\section{Consolidation - Programmation Orientée Objet}

\begin{Exercice}[10 minutes]{Encapsulation - Java}

L'encapsulation sert à cacher les détails d'implémentation. L'encapsulation sert uniquement à montrer que les informations essentielles aux utilisateurs.\\

En Java, il est recommandé de déclarer les attributs des classes comme étant \lstinline{private} et de mettre à disposition des utilisateurs des méthodes publiques d'accès afin qu'ils puissent accéder ou modifier la valeur des attributs privés.\\

Les méthodes publiques d'accès comme \lstinline{getName}et \lstinline{setName} doivent être nommées avec soit \lstinline{get} soit \lstinline{set} suivi du nom de l'attribut avec la 1ère lettre en majuscule (Java Naming convention)[https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html]). 

Le mot clé \lstinline{this} fait référence à l'objet en question.\\

\begin{enumerate}
	\item Dans votre IDE, créez une classe \lstinline{Person},
	\item Ajoutez-y un attribut privé \lstinline{name},
	\item Créez un getter et un setter pour l'attribut \lstinline{name} en suivant la convention de nommage des méthodes.
	\item Dans votre \lstinline{main}, créez une instance de \lstinline{Person}, 
	\item En utilisant le setter défini précédemment, donnez un nom (\lstinline{name}) à votre instance.
	\item Affichez le nom de l'instance en utilisant le getter de l'attribut \lstinline{name}.
\end{enumerate}
	\begin{solution}  
		\lstinputlisting{solutions/Person.java} 
	\end{solution}
\end{Exercice}
	
	
\begin{Exercice}[10 minutes]{Héritage - Java}

	Comme vous le savez, il est possible que des classes-filles héritent des attributs ou méthodes de classes-mères.
	En Java, il faut utiliser le mot-clé \lstinline{extends} lorsqu'on défini une classe-fille. Ainsi, l'héritage permet la réutilisation des attributs et méthodes d'une classe existante.

	\begin{enumerate}
		\item Créez une classe-mère \lstinline{Vehicle} ayant un attribut protégé appelé \lstinline{brand}.
		\item Créez un constructeur pour la classe \lstinline{Vehicle} et assignez une valeur à l'attribut \lstinline{brand}.
		\item Définissez une méthode \lstinline{honk} qui affiche \lstinline{"Tuut, tuut!"}
		\item Créez une classe-fille \lstinline{Car} qui hérite de \lstinline{Vehicle} et ayant pour attribut \lstinline{modelName} avec pour valeur par défaut \lstinline{"Mustang"}.
	\end{enumerate}

	\begin{conseil}
		Dans le constructeur de la classe-fille, n'oubliez pas de faire appel au constructeur de la classe-mère en utilisant le mot-clé \lstinline{super}
	\end{conseil}	
	
	\begin{solution}
		\lstinputlisting{solutions/Vehicle.java} 
	\end{solution}
\end{Exercice}
	

\section{Classes abstraites}
% Ajouter deux exercices sur les classes abstraites

\begin{Exercice}[15 minutes]{Création d'une classe abstraite}

	Une classe abstraite est une classe dont l'implémentation n'est pas complète et qui n'est pas instanciable. Elle est déclarée en utilisant le mot-clé \lstinline{abstract}. Elle peut inclure des méthodes abstraites ou non. Bien que ne pouvant être instanciées, les classes abstraites servent de base à des sous-classes qui en sont dérivées.
	Lorsqu'une sous-classe est dérivée d'une classe abstraite, elle complète généralement l'implémentation de toutes les méthodes abstraites de la classe-mère. Si ce n'est pas le cas, la sous-classe doit également être déclarée comme abstraite.
	
	\lstinputlisting{ressources/exo1.java} 
	
	\begin{itemize}
		\item Implémentez une classe abstraite appelée \lstinline{Item}.
		1. Elle doit avoir 4 attributs d'instance et un attribut de classe, qui sont les suivants:
		\lstinputlisting{ressources/variables_exo1.java} 
		\begin{conseil}
			Les attributs d'instance sont créés lors de l'instanciation d'un objet (à l'aide du mot clé \lstinline{new}) et détruits lors de la destruction de l'objet. Les attributs de classes (attributs statiques), quant à eux, sont créés lors de l'exécution du programme et détruits lors de l'arrêt du programme. En Java, les attributs de classes sont accessibles en utilisant le nom de la classe soit: \lstinline{ClassName.AttributeName}.
		\end{conseil}
		\item Créer un constructeur pour initialiser les attributs \lstinline{name, price, ingredients et id}. L'attribut \lstinline{id} incrémentera à chaque instanciation de la classe.
		\begin{conseil}
			Pensez à utilisez \lstinline{count} pour initialiser la valeur d'\lstinline{id}. Ainsi, dans le constructeur, \lstinline{id} sera égal à \lstinline{++count}.
		\end{conseil}
		\item Implémentez les \lstinline{getters} des attributs \lstinline{id, name, price et ingredients}.
		\item Implémentez les méthodes \lstinline{equals}(Object o) et \lstinline{toString}().
	
	\begin{conseil}
	La méthode \lstinline{equals} permet de comparer deux objets. Elle prend en entrée un objet de type \lstinline{Object} et doit retourner \lstinline{True} si l'objet instancié est égal à l'objet passé en paramètre.
	\end{conseil}
\end{itemize}
		\begin{solution}  
			\lstinputlisting{solutions/solution1.java} 
		\end{solution}
	\end{Exercice}
	
	
	\begin{Exercice}[15 minutes]{Classe abstraite et types d'attributs}
	\begin{itemize}
		\item Implémentez une classe abstraite \lstinline{Figure} contenant deux attributs protégés : \lstinline{largeur} et \lstinline{longueur} et deux méthodes abstraites : \lstinline{getAire}()et \lstinline{getPerimetre}().
		\item Créez deux classes \lstinline{Carre} et \lstinline{Rectangle} qui héritent de la classe \lstinline{Figure}. À l'intérieur de ces classes, implémentez les méthodes \lstinline{getAire()} et \lstinline{getPerimetre()}.
	\end{itemize}
	
	\begin{conseil}
		Un attribut protégé est accessible aussi bien dans la classe-mère que dans la(les) classe(s)-fille(s). On utilise le mot clé \lstinline{protected} pour rendre des attributs protégés. \\
		Pour rappel, pour créer une classe fille, on utilise le mot-clé \lstinline{extends}:\lstinline{public class Carre extends Figure}.
	\end{conseil}
	
	
	\begin{solution}
	\lstinputlisting{solutions/Figure.java} 
	\end{solution}
	\end{Exercice}
	
	\newpage
\section{Interfaces}
\begin{Exercice}[15 minutes]{Interface et héritage (\faLink~~Liée à la question 1)}\\

En Java, une interface se déclare comme suit:
\lstinputlisting{ressources/interface_exemple1.java} 

Les méthodes déclarées dans une interface doivent être implémentées dans des sous-classes :

\lstinputlisting{ressources/interface_exemple2.java} 
\begin{itemize}
	\item Implémentez une interface \lstinline{Edible} contenant une méthode \lstinline{eatMe} qui ne retourne aucune valeur.
	\item Implémentez une interface \lstinline{Drinkable} contenant une méthode \lstinline{drinkMe} qui ne retourne aucune valeur.
	\item Implémentez une classe \lstinline{Food} qui hérite la classe \lstinline{Item} (définie dans la section 1) et qui implémente l'interface \lstinline{Edible}. Implémentez le constructeur de \lstinline{Food} et la méthode \lstinline{eatMe} (dans la classe \lstinline{Food}).
\end{itemize}

\begin{conseil}
Vous pouvez reprendre la classe \lstinline{Item} du premier exercice.\\
Dans la méthode \lstinline{eatMe()}, vous pouvez simplement afficher un message en utilisant un \lstinline{println}.
\end{conseil}

Certains aliments ne sont pas seulement \lstinline{Edible} (mangeable) mais aussi \lstinline{Drinkable} (buvable) comme les soupes par exemple.\\

4. Implémentez une classe \lstinline{Soup} qui hérite de \lstinline{Food} et implémente l'interface \lstinline{Drinkable}. Ensuite, implémentez à la fois un constructeur pour \lstinline{Soup} ainsi que la méthode \lstinline{drinkMe} (dans la classe \lstinline{Soup}).\\

Vous pouvez ensuite créer des instances de \lstinline{Soup} et \lstinline{Food} à l'aide des lignes suivantes pour tester les méthodes \lstinline{eatMe()} et \lstinline{drinkMe()}.
\lstinputlisting{ressources/fin_interface.java} 

\begin{solution}
\lstinputlisting{solutions/interface.java} 
\end{solution}
\end{Exercice}

%TODO: Ajouter une question sur les interfaces

\newpage


% Ajouter des questions sur la récursivité

% Question sur la manipulation avancée de listes et dictionnaires



\end{document}